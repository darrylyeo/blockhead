diff --git a/tscodegen-DUJe0_td.cjs b/tscodegen-DUJe0_td.cjs
index e4232294f43d5a4ab2b16f36ba2e3c1c4a037237..0ec4465b645892921d66a5dba325ec2d4fd996e1 100644
--- a/tscodegen-DUJe0_td.cjs
+++ b/tscodegen-DUJe0_td.cjs
@@ -1,4 +1,4 @@
-"use strict";var Xe=Object.defineProperty;var Ae=Object.getOwnPropertySymbols;var et=Object.prototype.hasOwnProperty,tt=Object.prototype.propertyIsEnumerable;var ae=(t,e,r)=>e in t?Xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,je=(t,e)=>{for(var r in e||(e={}))et.call(e,r)&&ae(t,r,e[r]);if(Ae)for(var r of Ae(e))tt.call(e,r)&&ae(t,r,e[r]);return t};var j=(t,e,r)=>(ae(t,typeof e!="symbol"?e+"":e,r),r);const u=require("typescript"),O=require("lodash"),V=u.factory;function rt(t){const e=t.split(/{([\s\S]+?)}/g),r=O.chunk(e.slice(1),2);return ne(e[0],r.map(([i,n])=>({expression:V.createIdentifier(i),literal:n})))}function nt(t,e){const r=[v(H(Object.entries(e||{}).map(([i,n])=>({name:i,initializer:X(n.default)}))),{type:V.createTypeLiteralNode(Object.entries(e||{}).map(([i,n])=>x({name:i,type:n.enum?ee(n.enum):V.createUnionTypeNode([l.string,l.number,l.boolean])})))})];return de(r,rt(t))}function it(t){return t.variables?nt(t.url,t.variables):V.createStringLiteral(t.url)}function ot(t){if(!t)return"/";const{url:e,variables:r}=t;return r?e.replace(/\{(.+?)\}/g,(i,n)=>r[n]?String(r[n].default):i):e}function Le(t){return V.createStringLiteral(ot(t[0]))}function st(t,e){return t.description?O.camelCase(t.description.replace(/\W+/," ")):`server${e+1}`}function at(t){return re(t.map((e,r)=>[st(e,r),it(e)]))}const a=u.factory,Ke=["GET","PUT","POST","DELETE","OPTIONS","HEAD","PATCH","TRACE"],Pe={"*/*":"json","application/json":"json","application/x-www-form-urlencoded":"form","multipart/form-data":"multipart"};function Ie(t){return typeof t=="string"&&/^[^/]+\/[^/]+$/.test(t)}function Z(t){return Pe[t]==="json"||/\bjson\b/i.test(t)}function Re(t){if(t!=null&&t.content)for(const e of Object.keys(t.content)){const r=Pe[e];if(r)return r;if(Z(e))return"json"}}function Ce({style:t="form",explode:e=!0,content:r}){if(r){const i=Object.keys(r);if(i.length!==1)throw new Error("Parameters with content property must specify one media type");if(!Z(i[0]))throw new Error("Parameters with content property must specify a JSON compatible media type");return"json"}return e&&t==="deepObject"?"deep":e?"explode":t==="spaceDelimited"?"space":t==="pipeDelimited"?"pipe":"form"}function $e(t){if(t&&!t.match(/[^\w\s]/)&&(t=O.camelCase(t),W(t)))return t}function Ue(t,e,r){const i=$e(r);return i||(e=e.replace(/\{(.+?)\}/,"by $1").replace(/\{(.+?)\}/,"and $1"),N(`${t} ${e}`))}function qe(t){return typeof t=="boolean"?t:t&&"nullable"in t?!w(t)&&t.nullable:!1}function w(t){return typeof t=="object"&&t!==null&&"$ref"in t}function pe(t){if(!t.startsWith("#/"))throw new Error(`External refs are not supported (${t}). Make sure to call SwaggerParser.bundle() first.`);return t.slice(2).split("/").map(e=>decodeURI(e.replace(/~1/g,"/").replace(/~0/g,"~")))}function U(t){return t.replace(/.+\//,"")}function ct(t){const e=U(t);return/^\d+/.test(e)?pe(t).join("_"):e}function ce(t){if(w(t))return U(t.$ref)}const ut={readOnly:"Read",writeOnly:"Write"};function pt(t){return t?ut[t]:""}function N(t,e=!1,r){let i=O.camelCase(t)+pt(r);return e&&(i=O.upperFirst(i)),W(i)?i:"$"+i}function De(t,e){const r=[],i=t.replace(/(.*?)\{(.+?)\}(.*?)(?=\{|$)/g,(n,o,s,p)=>{const f=N(s);return r.push({expression:q(a.createIdentifier("encodeURIComponent"),{args:[a.createIdentifier(f)]}),literal:p}),o});return e&&r.push({expression:e,literal:""}),ne(i,r)}function ue(t,e){return q(a.createPropertyAccessExpression(a.createIdentifier("QS"),t),{args:e})}function B(t,e,r){return q(a.createPropertyAccessExpression(a.createIdentifier("oazapfts"),t),{args:e,typeArgs:r})}function Me(t){const e=[],r={};return t.forEach(i=>{const n=/^(.+?)\[(.*?)\]/.exec(i.name);if(!n){e.push(i);return}const[,o,s]=n;let p=r[o];p||(p=r[o]={name:o,in:i.in,style:"deepObject",schema:{type:"object",properties:{}}},e.push(p)),p.schema.properties[s]=i.schema}),e}function ke(t){return t in l}class ft{constructor(e,r={},i=!1){j(this,"discriminatingSchemas",new Set);j(this,"aliases",[]);j(this,"enumAliases",[]);j(this,"enumRefs",{});j(this,"refs",{});j(this,"refsOnlyMode",new Map);j(this,"typeAliases",{});var n;this.spec=e,this.opts=r,this.isConverted=i,(n=this.spec.components)!=null&&n.schemas&&this.preprocessComponents(this.spec.components.schemas)}reset(){this.aliases=[],this.enumAliases=[],this.refs={},this.typeAliases={}}resolve(e){if(!w(e))return e;const r=e.$ref,i=pe(r),n=O.get(this.spec,i);if(typeof n=="undefined")throw new Error(`Can't find ${i}`);return n}resolveArray(e){return e?e.map(r=>this.resolve(r)):[]}skip(e){var i;return e&&e.some(n=>{var o,s;return(s=(o=this.opts)==null?void 0:o.exclude)==null?void 0:s.includes(n)})?!0:(i=this.opts)!=null&&i.include?!(e&&e.some(o=>{var s;return(s=this.opts.include)==null?void 0:s.includes(o)})):!1}findAvailableRef(e){const r=n=>{try{return this.resolve({$ref:n}),!1}catch(o){return!0}};if(r(e))return e;let i=2;for(;;){const n=e+String(i);if(r(n))return n;i+=1}}getUniqueAlias(e){let r=this.typeAliases[e]||0;return r&&(this.typeAliases[e]=++r,e+=r),this.typeAliases[e]=1,e}getEnumUniqueAlias(e,r){return this.enumRefs[e]&&this.enumRefs[e].values==r?e:this.getUniqueAlias(e)}getRefAlias(e,r,i){var o;const n=i?this.findAvailableRef(e.$ref+"Base"):e.$ref;if(!this.refs[n]){let s=this.resolve(e);typeof s!="boolean"&&i&&(s=O.cloneDeep(s),delete s.discriminator);const p=typeof s!="boolean"&&s.title||ct(n),f=N(p,!0);if(this.isTrueEnum(s,p))return this.getTypeFromSchema(s,p);const y=this.getUniqueAlias(f);this.refs[n]={base:a.createTypeReferenceNode(y,void 0),readOnly:void 0,writeOnly:void 0};const T=this.getTypeFromSchema(s,void 0);this.aliases.push(z({modifiers:[I.export],name:y,type:T}));const{readOnly:g,writeOnly:h}=this.checkSchemaOnlyMode(s);if(g){const S=this.getUniqueAlias(N(p,!0,"readOnly"));this.refs[n].readOnly=a.createTypeReferenceNode(S,void 0);const F=this.getTypeFromSchema(s,p,"readOnly");this.aliases.push(z({modifiers:[I.export],name:S,type:F}))}if(h){const S=this.getUniqueAlias(N(p,!0,"writeOnly"));this.refs[n].writeOnly=a.createTypeReferenceNode(S,void 0);const F=this.getTypeFromSchema(s,p,"writeOnly");this.aliases.push(z({modifiers:[I.export],name:S,type:F}))}}return(o=this.refs[n][r||"base"])!=null?o:this.refs[n].base}getUnionType(e,r,i){if(r){if(r.propertyName===void 0)throw new Error("Discriminators require a propertyName");const n=new Set(Object.values(r.mapping||{}).map(U));return a.createUnionTypeNode([...Object.entries(r.mapping||{}).map(([o,s])=>[o,{$ref:s}]),...e.filter(o=>{if(!w(o))throw new Error("Discriminators require references, not inline schemas");return!n.has(U(o.$ref))}).map(o=>[U(o.$ref),o])].map(([o,s])=>a.createIntersectionTypeNode([a.createTypeLiteralNode([x({name:r.propertyName,type:a.createLiteralTypeNode(a.createStringLiteral(o))})]),this.getTypeFromSchema(s,void 0,i)])))}else return a.createUnionTypeNode(e.map(n=>this.getTypeFromSchema(n,void 0,i)))}getTypeFromSchema(e,r,i){const n=this.getBaseTypeFromSchema(e,r,i);return qe(e)?a.createUnionTypeNode([n,l.null]):n}getBaseTypeFromSchema(e,r,i){if(!e&&typeof e!="boolean")return l.any;if(w(e))return this.getRefAlias(e,i);if(e===!0)return l.any;if(e===!1)return l.never;if(e.oneOf){const n=je({},e);return delete n.oneOf,this.getUnionType(e.oneOf.map(o=>O.mergeWith({},n,o,(s,p)=>{if(O.isArray(s))return s.concat(p)})),e.discriminator,i)}if(e.anyOf)return this.getUnionType(e.anyOf,void 0,i);if(e.discriminator){const n=e.discriminator.mapping||{};return this.getUnionType(Object.values(n).map(o=>({$ref:o})),void 0,i)}if(e.allOf){const n=[];for(const o of e.allOf)if(w(o)&&this.discriminatingSchemas.has(o.$ref)){const p=this.resolve(o).discriminator,f=Object.entries(p.mapping||{}).find(([,y])=>y===e["x-component-ref-path"]);if(f){const[y]=f;n.push(a.createTypeLiteralNode([x({name:p.propertyName,type:a.createLiteralTypeNode(a.createStringLiteral(y))})]))}n.push(this.getRefAlias(o,i,!0))}else n.push(this.getTypeFromSchema(o,void 0,i));return(e.properties||e.additionalProperties)&&n.push(this.getTypeFromProperties(e.properties||{},e.required,e.additionalProperties,i)),a.createIntersectionTypeNode(n)}return"items"in e?a.createArrayTypeNode(this.getTypeFromSchema(e.items,void 0,i)):"prefixItems"in e&&e.prefixItems?a.createTupleTypeNode(e.prefixItems.map(n=>this.getTypeFromSchema(n))):e.properties||e.additionalProperties?this.getTypeFromProperties(e.properties||{},e.required,e.additionalProperties,i):e.enum?this.isTrueEnum(e,r)?this.getTrueEnum(e,r):ee(e.enum):e.format=="binary"?a.createTypeReferenceNode("Blob",[]):e.const?this.getTypeFromEnum([e.const]):e.type?Array.isArray(e.type)?a.createUnionTypeNode(e.type.map(n=>n==="null"?l.null:n==="integer"?l.number:ke(n)?l[n]:l.any)):e.type==="integer"?l.number:ke(e.type)?l[e.type]:l.any:l.any}isTrueEnum(e,r){return!!(typeof e!="boolean"&&e.enum&&this.opts.useEnumType&&r&&e.type!=="boolean")}getTypeFromEnum(e){const r=e.map(i=>{if(i===null)return l.null;if(typeof i=="boolean")return i?a.createLiteralTypeNode(u.factory.createToken(u.SyntaxKind.TrueKeyword)):a.createLiteralTypeNode(u.factory.createToken(u.SyntaxKind.FalseKeyword));if(typeof i=="number")return a.createLiteralTypeNode(a.createNumericLiteral(i));if(typeof i=="string")return a.createLiteralTypeNode(a.createStringLiteral(i));throw new Error(`Unexpected ${String(i)} of type ${typeof i} in enum`)});return r.length>1?a.createUnionTypeNode(r):r[0]}getEnumValuesString(e){return e.join("_")}getTrueEnum(e,r){var g;if(typeof e=="boolean")throw new Error("cannot get enum from boolean schema. schema must be an object");const n=(e.title||O.upperFirst(r)).split(/[^A-Za-z0-9$_]/g).map(h=>O.upperFirst(h)).join(""),o=this.getEnumValuesString(e.enum?e.enum:[]),s=this.getEnumUniqueAlias(n,o);if(this.enumRefs[n]&&n===s)return this.enumRefs[n].type;const p=e.enum?e.enum:[],f=(g=e["x-enumNames"])!=null?g:e["x-enum-varnames"];if(f){if(!Array.isArray(f))throw new Error("enum names must be an array");if(f.length!==p.length)throw new Error("enum names must have the same length as enum values")}const y=p.map((h,S)=>{if(e.type==="number"||e.type==="integer"){const F=f?f[S]:String(h);return a.createEnumMember(a.createIdentifier(N(F,!0)),a.createNumericLiteral(h))}return a.createEnumMember(a.createIdentifier(N(h,!0)),a.createStringLiteral(h))});this.enumAliases.push(a.createEnumDeclaration([I.export],s,y));const T=a.createTypeReferenceNode(s,void 0);return this.enumRefs[n]={values:o,type:a.createTypeReferenceNode(s,void 0)},T}checkSchemaOnlyMode(e,r=!0){if(this.opts.mergeReadWriteOnly)return{readOnly:!1,writeOnly:!1};const i=(n,o)=>{var y,T,g,h,S,F;if(w(n)){if(!r)return{readOnly:!1,writeOnly:!1};if(o.has(n.$ref))return{readOnly:!1,writeOnly:!1};const R=this.refsOnlyMode.get(n.$ref);if(R)return R;o.add(n.$ref);const k=i(this.resolve(n),o);return o.delete(n.$ref),this.refsOnlyMode.set(n.$ref,k),k}if(typeof n=="boolean")return{readOnly:!1,writeOnly:!1};let s=(y=n.readOnly)!=null?y:!1,p=(T=n.writeOnly)!=null?T:!1;const f=[];"items"in n&&n.items?f.push(n.items):(f.push(...Object.values((g=n.properties)!=null?g:{})),f.push(...(h=n.allOf)!=null?h:[]),f.push(...(S=n.anyOf)!=null?S:[]),f.push(...(F=n.oneOf)!=null?F:[]));for(const R of f){if(s&&p)break;const k=i(R,o);s=s||k.readOnly,p=p||k.writeOnly}return{readOnly:s,writeOnly:p}};return i(e,new Set)}getTypeFromProperties(e,r,i,n){const p=Object.keys(e).filter(f=>{const y=e[f],{readOnly:T,writeOnly:g}=this.checkSchemaOnlyMode(y,!1);switch(n){case"readOnly":return T||!g;case"writeOnly":return g||!T;default:return!T&&!g}}).map(f=>{const y=e[f],T=r&&r.includes(f);let g=this.getTypeFromSchema(y,f,n);!T&&this.opts.unionUndefined&&(g=a.createUnionTypeNode([g,l.undefined]));const h=x({questionToken:!T,name:f,type:g});if(typeof y!="boolean"&&"description"in y&&y.description){const S=y.description.replace("*/","*\\/");u.addSyntheticLeadingComment(h,u.SyntaxKind.MultiLineCommentTrivia,`* ${S} `,!0)}return h});if(i){const f=i===!0?l.any:this.getTypeFromSchema(i,void 0,n);p.push(me(f))}return a.createTypeLiteralNode(p)}getTypeFromResponses(e,r){return a.createUnionTypeNode(Object.entries(e).map(([i,n])=>{const o=i==="default"?l.number:a.createLiteralTypeNode(a.createNumericLiteral(i)),s=[x({name:"status",type:o})],p=this.getTypeFromResponse(n,r);return p!==l.void&&s.push(x({name:"data",type:p})),a.createTypeLiteralNode(s)}))}getTypeFromResponse(e,r){const i=this.resolve(e);return!i||!i.content?l.void:this.getTypeFromSchema(this.getSchemaFromContent(i.content),void 0,r)}getResponseType(e){if(!e)return"text";const r=Object.values(e).map(n=>this.resolve(n));return r.some(n=>{var o;return Object.keys((o=n.content)!=null?o:{}).length>0})?r.some(n=>{var s;return Object.keys((s=n.content)!=null?s:{}).some(Z)})?"json":r.some(n=>{var o;return Object.keys((o=n.content)!=null?o:[]).some(s=>s.startsWith("text/"))})?"text":"blob":"text"}getSchemaFromContent(e){const r=Object.keys(e).find(Ie);if(r){const{schema:i}=e[r];if(i)return i}return Object.keys(e).length===0||Object.keys(e).some(i=>i.startsWith("text/"))?{type:"string"}:{type:"string",format:"binary"}}getTypeFromParameter(e){if(e.content){const r=this.getSchemaFromContent(e.content);return this.getTypeFromSchema(r)}return this.getTypeFromSchema(w(e)?e:e.schema)}wrapResult(e){var r;return(r=this.opts)!=null&&r.optimistic?B("ok",[e]):e}preprocessComponents(e){const r="#/components/schemas/";for(const n of Object.keys(e)){const o=e[n];w(o)||typeof o=="boolean"||(o["x-component-ref-path"]=r+n,typeof o!="boolean"&&o.discriminator&&!o.oneOf&&!o.anyOf&&this.discriminatingSchemas.add(r+n))}const i=(n,o)=>Object.values(n.mapping||{}).includes(o);for(const n of Object.keys(e)){const o=e[n];if(!(w(o)||typeof o=="boolean"||!o.allOf))for(const s of o.allOf){if(!w(s)||!this.discriminatingSchemas.has(s.$ref))continue;const f=e[U(s.$ref)].discriminator;i(f,r+n)||(f.mapping||(f.mapping={}),f.mapping[n]=r+n)}}}generateApi(){this.reset();const e=u.createSourceFile("ApiStub.ts",`/**
+"use strict";var Xe=Object.defineProperty;var Ae=Object.getOwnPropertySymbols;var et=Object.prototype.hasOwnProperty,tt=Object.prototype.propertyIsEnumerable;var ae=(t,e,r)=>e in t?Xe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,je=(t,e)=>{for(var r in e||(e={}))et.call(e,r)&&ae(t,r,e[r]);if(Ae)for(var r of Ae(e))tt.call(e,r)&&ae(t,r,e[r]);return t};var j=(t,e,r)=>(ae(t,typeof e!="symbol"?e+"":e,r),r);const u=require("typescript"),O=require("lodash"),V=u.factory;function rt(t){const e=t.split(/{([\s\S]+?)}/g),r=O.chunk(e.slice(1),2);return ne(e[0],r.map(([i,n])=>({expression:V.createIdentifier(i),literal:n})))}function nt(t,e){const r=[v(H(Object.entries(e||{}).map(([i,n])=>({name:i,initializer:X(n.default)}))),{type:V.createTypeLiteralNode(Object.entries(e||{}).map(([i,n])=>x({name:i,type:n.enum?ee(n.enum):V.createUnionTypeNode([l.string,l.number,l.boolean])})))})];return de(r,rt(t))}function it(t){return t.variables?nt(t.url,t.variables):V.createStringLiteral(t.url)}function ot(t){if(!t)return"/";const{url:e,variables:r}=t;return r?e.replace(/\{(.+?)\}/g,(i,n)=>r[n]?String(r[n].default):i):e}function Le(t){return V.createStringLiteral(ot(t[0]))}function st(t,e){return t.description?O.camelCase(t.description.replace(/\W+/," ")):`server${e+1}`}function at(t){return re(t.map((e,r)=>[st(e,r),it(e)]))}const a=u.factory,Ke=["GET","PUT","POST","DELETE","OPTIONS","HEAD","PATCH","TRACE"],Pe={"*/*":"json","application/json":"json","application/x-www-form-urlencoded":"form","multipart/form-data":"multipart"};function Ie(t){return typeof t=="string"&&/^[^/]+\/[^/]+$/.test(t)}function Z(t){return Pe[t]==="json"||/\bjson\b/i.test(t)}function Re(t){if(t!=null&&t.content)for(const e of Object.keys(t.content)){const r=Pe[e];if(r)return r;if(Z(e))return"json"}}function Ce({style:t="form",explode:e=!0,content:r}){if(r){const i=Object.keys(r);if(i.length!==1)throw new Error("Parameters with content property must specify one media type");if(!Z(i[0]))throw new Error("Parameters with content property must specify a JSON compatible media type");return"json"}return e&&t==="deepObject"?"deep":e?"explode":t==="spaceDelimited"?"space":t==="pipeDelimited"?"pipe":"form"}function $e(t){if(t&&!t.match(/[^\w\s]/)&&(t=O.camelCase(t),W(t)))return t}function Ue(t,e,r){const i=$e(r);return i||(e=e.replace(/\{(.+?)\}/,"by $1").replace(/\{(.+?)\}/,"and $1"),N(`${t} ${e}`))}function qe(t){return typeof t=="boolean"?t:t&&"nullable"in t?!w(t)&&t.nullable:!1}function w(t){return typeof t=="object"&&t!==null&&"$ref"in t}function pe(t){if(!t.startsWith("#/"))throw new Error(`External refs are not supported (${t}). Make sure to call SwaggerParser.bundle() first.`);return t.slice(2).split("/").map(e=>decodeURI(e.replace(/~1/g,"/").replace(/~0/g,"~")))}function U(t){return t.replace(/.+\//,"")}function ct(t){const e=U(t);return/^\d+/.test(e)?pe(t).join("_"):e}function ce(t){if(w(t))return U(t.$ref)}const ut={readOnly:"Read",writeOnly:"Write"};function pt(t){return t?ut[t]:""}function N(t,e=!1,r){let i=O.camelCase(t)+pt(r);return e&&(i=O.upperFirst(i)),W(i)?i:"$"+i}function De(t,e){const r=[],i=t.replace(/(.*?)\{(.+?)\}(.*?)(?=\{|$)/g,(n,o,s,p)=>{const f=N(s);return r.push({expression:q(a.createIdentifier("encodeURIComponent"),{args:[a.createIdentifier(f)]}),literal:p}),o});return e&&r.push({expression:e,literal:""}),ne(i,r)}function ue(t,e){return q(a.createPropertyAccessExpression(a.createIdentifier("QS"),t),{args:e})}function B(t,e,r){return q(a.createPropertyAccessExpression(a.createIdentifier("oazapfts"),t),{args:e,typeArgs:r})}function Me(t){const e=[],r={};return t.forEach(i=>{const n=/^(.+?)\[(.*?)\]/.exec(i.name);if(!n){e.push(i);return}const[,o,s]=n;let p=r[o];p||(p=r[o]={name:o,in:i.in,style:"deepObject",schema:{type:"object",properties:{}}},e.push(p)),p.schema.properties[s]=i.schema}),e}function ke(t){return t in l}class ft{constructor(e,r={},i=!1){j(this,"discriminatingSchemas",new Set);j(this,"aliases",[]);j(this,"enumAliases",[]);j(this,"enumRefs",{});j(this,"refs",{});j(this,"refsOnlyMode",new Map);j(this,"typeAliases",{});var n;this.spec=e,this.opts=r,this.isConverted=i,(n=this.spec.components)!=null&&n.schemas&&this.preprocessComponents(this.spec.components.schemas)}reset(){this.aliases=[],this.enumAliases=[],this.refs={},this.typeAliases={}}resolve(e){if(!w(e))return e;const r=e.$ref,i=pe(r),n=O.get(this.spec,i);if(typeof n=="undefined")throw new Error(`Can't find ${i}`);return n}resolveArray(e){return e?e.map(r=>this.resolve(r)):[]}skip(e){var i;return e&&e.some(n=>{var o,s;return(s=(o=this.opts)==null?void 0:o.exclude)==null?void 0:s.includes(n)})?!0:(i=this.opts)!=null&&i.include?!(e&&e.some(o=>{var s;return(s=this.opts.include)==null?void 0:s.includes(o)})):!1}findAvailableRef(e){const r=n=>{try{return this.resolve({$ref:n}),!1}catch(o){return!0}};if(r(e))return e;let i=2;for(;;){const n=e+String(i);if(r(n))return n;i+=1}}getUniqueAlias(e){let r=this.typeAliases[e]||0;return r&&(this.typeAliases[e]=++r,e+=r),this.typeAliases[e]=1,e}getEnumUniqueAlias(e,r){return this.enumRefs[e]&&this.enumRefs[e].values==r?e:this.getUniqueAlias(e)}getRefAlias(e,r,i){var o;const n=i?this.findAvailableRef(e.$ref+"Base"):e.$ref;if(!this.refs[n]){let s=this.resolve(e);typeof s!="boolean"&&i&&(s=O.cloneDeep(s),delete s.discriminator);const p=typeof s!="boolean"&&s.title||ct(n),f=N(p,!0);if(this.isTrueEnum(s,p))return this.getTypeFromSchema(s,p);const y=this.getUniqueAlias(f);this.refs[n]={base:a.createTypeReferenceNode(y,void 0),readOnly:void 0,writeOnly:void 0};const T=this.getTypeFromSchema(s,void 0);this.aliases.push(z({modifiers:[I.export],name:y,type:T}));const{readOnly:g,writeOnly:h}=this.checkSchemaOnlyMode(s);if(g){const S=this.getUniqueAlias(N(p,!0,"readOnly"));this.refs[n].readOnly=a.createTypeReferenceNode(S,void 0);const F=this.getTypeFromSchema(s,p,"readOnly");this.aliases.push(z({modifiers:[I.export],name:S,type:F}))}if(h){const S=this.getUniqueAlias(N(p,!0,"writeOnly"));this.refs[n].writeOnly=a.createTypeReferenceNode(S,void 0);const F=this.getTypeFromSchema(s,p,"writeOnly");this.aliases.push(z({modifiers:[I.export],name:S,type:F}))}}return(o=this.refs[n][r||"base"])!=null?o:this.refs[n].base}getUnionType(e,r,i){if(r){if(r.propertyName===void 0)throw new Error("Discriminators require a propertyName");const n=new Set(Object.values(r.mapping||{}).map(U));return a.createUnionTypeNode([...Object.entries(r.mapping||{}).map(([o,s])=>[o,{$ref:s}]),...e.filter(o=>{if(!w(o))throw new Error("Discriminators require references, not inline schemas");return!n.has(U(o.$ref))}).map(o=>[U(o.$ref),o])].map(([o,s])=>a.createIntersectionTypeNode([a.createTypeLiteralNode([x({name:r.propertyName,type:a.createLiteralTypeNode(a.createStringLiteral(o))})]),this.getTypeFromSchema(s,void 0,i)])))}else return a.createUnionTypeNode(e.map(n=>this.getTypeFromSchema(n,void 0,i)))}getTypeFromSchema(e,r,i){const n=this.getBaseTypeFromSchema(e,r,i);return qe(e)?a.createUnionTypeNode([n,l.null]):n}getBaseTypeFromSchema(e,r,i){if(!e&&typeof e!="boolean")return l.any;if(w(e))return this.getRefAlias(e,i);if(e===!0)return l.any;if(e===!1)return l.never;if(e.oneOf){const n=je({},e);return delete n.oneOf,this.getUnionType(e.oneOf.map(o=>O.mergeWith({},n,o,(s,p)=>{if(O.isArray(s))return s.concat(p)})),e.discriminator,i)}if(e.anyOf)return this.getUnionType(e.anyOf,void 0,i);if(e.discriminator){const n=e.discriminator.mapping||{};return this.getUnionType(Object.values(n).map(o=>({$ref:o})),void 0,i)}if(e.allOf){const n=[];for(const o of e.allOf)if(w(o)&&this.discriminatingSchemas.has(o.$ref)){const p=this.resolve(o).discriminator,f=Object.entries(p.mapping||{}).find(([,y])=>y===e["x-component-ref-path"]);if(f){const[y]=f;n.push(a.createTypeLiteralNode([x({name:p.propertyName,type:a.createLiteralTypeNode(a.createStringLiteral(y))})]))}n.push(this.getRefAlias(o,i,!0))}else n.push(this.getTypeFromSchema(o,void 0,i));return(e.properties||e.additionalProperties)&&n.push(this.getTypeFromProperties(e.properties||{},e.required,e.additionalProperties,i)),a.createIntersectionTypeNode(n)}return"items"in e&typeof e==="object"?a.createArrayTypeNode(this.getTypeFromSchema(e.items,void 0,i)):"prefixItems"in e&&e.prefixItems?a.createTupleTypeNode(e.prefixItems.map(n=>this.getTypeFromSchema(n))):e.properties||e.additionalProperties?this.getTypeFromProperties(e.properties||{},e.required,e.additionalProperties,i):e.enum?this.isTrueEnum(e,r)?this.getTrueEnum(e,r):ee(e.enum):e.format=="binary"?a.createTypeReferenceNode("Blob",[]):e.const?this.getTypeFromEnum([e.const]):e.type?Array.isArray(e.type)?a.createUnionTypeNode(e.type.map(n=>n==="null"?l.null:n==="integer"?l.number:ke(n)?l[n]:l.any)):e.type==="integer"?l.number:ke(e.type)?l[e.type]:l.any:l.any}isTrueEnum(e,r){return!!(typeof e!="boolean"&&e.enum&&this.opts.useEnumType&&r&&e.type!=="boolean")}getTypeFromEnum(e){const r=e.map(i=>{if(i===null)return l.null;if(typeof i=="boolean")return i?a.createLiteralTypeNode(u.factory.createToken(u.SyntaxKind.TrueKeyword)):a.createLiteralTypeNode(u.factory.createToken(u.SyntaxKind.FalseKeyword));if(typeof i=="number")return a.createLiteralTypeNode(a.createNumericLiteral(i));if(typeof i=="string")return a.createLiteralTypeNode(a.createStringLiteral(i));throw new Error(`Unexpected ${String(i)} of type ${typeof i} in enum`)});return r.length>1?a.createUnionTypeNode(r):r[0]}getEnumValuesString(e){return e.join("_")}getTrueEnum(e,r){var g;if(typeof e=="boolean")throw new Error("cannot get enum from boolean schema. schema must be an object");const n=(e.title||O.upperFirst(r)).split(/[^A-Za-z0-9$_]/g).map(h=>O.upperFirst(h)).join(""),o=this.getEnumValuesString(e.enum?e.enum:[]),s=this.getEnumUniqueAlias(n,o);if(this.enumRefs[n]&&n===s)return this.enumRefs[n].type;const p=e.enum?e.enum:[],f=(g=e["x-enumNames"])!=null?g:e["x-enum-varnames"];if(f){if(!Array.isArray(f))throw new Error("enum names must be an array");if(f.length!==p.length)throw new Error("enum names must have the same length as enum values")}const y=p.map((h,S)=>{if(e.type==="number"||e.type==="integer"){const F=f?f[S]:String(h);return a.createEnumMember(a.createIdentifier(N(F,!0)),a.createNumericLiteral(h))}return a.createEnumMember(a.createIdentifier(N(h,!0)),a.createStringLiteral(h))});this.enumAliases.push(a.createEnumDeclaration([I.export],s,y));const T=a.createTypeReferenceNode(s,void 0);return this.enumRefs[n]={values:o,type:a.createTypeReferenceNode(s,void 0)},T}checkSchemaOnlyMode(e,r=!0){if(this.opts.mergeReadWriteOnly)return{readOnly:!1,writeOnly:!1};const i=(n,o)=>{var y,T,g,h,S,F;if(w(n)){if(!r)return{readOnly:!1,writeOnly:!1};if(o.has(n.$ref))return{readOnly:!1,writeOnly:!1};const R=this.refsOnlyMode.get(n.$ref);if(R)return R;o.add(n.$ref);const k=i(this.resolve(n),o);return o.delete(n.$ref),this.refsOnlyMode.set(n.$ref,k),k}if(typeof n=="boolean")return{readOnly:!1,writeOnly:!1};let s=(y=n.readOnly)!=null?y:!1,p=(T=n.writeOnly)!=null?T:!1;const f=[];"items"in n&&n.items&&typeof n.items==="object"?f.push(n.items):(f.push(...Object.values((g=n.properties)!=null?g:{})),f.push(...(h=n.allOf)!=null?h:[]),f.push(...(S=n.anyOf)!=null?S:[]),f.push(...(F=n.oneOf)!=null?F:[]));for(const R of f){if(s&&p)break;const k=i(R,o);s=s||k.readOnly,p=p||k.writeOnly}return{readOnly:s,writeOnly:p}};return i(e,new Set)}getTypeFromProperties(e,r,i,n){const p=Object.keys(e).filter(f=>{const y=e[f],{readOnly:T,writeOnly:g}=this.checkSchemaOnlyMode(y,!1);switch(n){case"readOnly":return T||!g;case"writeOnly":return g||!T;default:return!T&&!g}}).map(f=>{const y=e[f],T=r&&r.includes(f);let g=this.getTypeFromSchema(y,f,n);!T&&this.opts.unionUndefined&&(g=a.createUnionTypeNode([g,l.undefined]));const h=x({questionToken:!T,name:f,type:g});if(typeof y!="boolean"&&"description"in y&&y.description){const S=y.description.replace("*/","*\\/");u.addSyntheticLeadingComment(h,u.SyntaxKind.MultiLineCommentTrivia,`* ${S} `,!0)}return h});if(i){const f=i===!0?l.any:this.getTypeFromSchema(i,void 0,n);p.push(me(f))}return a.createTypeLiteralNode(p)}getTypeFromResponses(e,r){return a.createUnionTypeNode(Object.entries(e).map(([i,n])=>{const o=i==="default"?l.number:a.createLiteralTypeNode(a.createNumericLiteral(i)),s=[x({name:"status",type:o})],p=this.getTypeFromResponse(n,r);return p!==l.void&&s.push(x({name:"data",type:p})),a.createTypeLiteralNode(s)}))}getTypeFromResponse(e,r){const i=this.resolve(e);return!i||!i.content?l.void:this.getTypeFromSchema(this.getSchemaFromContent(i.content),void 0,r)}getResponseType(e){if(!e)return"text";const r=Object.values(e).map(n=>this.resolve(n));return r.some(n=>{var o;return Object.keys((o=n.content)!=null?o:{}).length>0})?r.some(n=>{var s;return Object.keys((s=n.content)!=null?s:{}).some(Z)})?"json":r.some(n=>{var o;return Object.keys((o=n.content)!=null?o:[]).some(s=>s.startsWith("text/"))})?"text":"blob":"text"}getSchemaFromContent(e){const r=Object.keys(e).find(Ie);if(r){const{schema:i}=e[r];if(i)return i}return Object.keys(e).length===0||Object.keys(e).some(i=>i.startsWith("text/"))?{type:"string"}:{type:"string",format:"binary"}}getTypeFromParameter(e){if(e.content){const r=this.getSchemaFromContent(e.content);return this.getTypeFromSchema(r)}return this.getTypeFromSchema(w(e)?e:e.schema)}wrapResult(e){var r;return(r=this.opts)!=null&&r.optimistic?B("ok",[e]):e}preprocessComponents(e){const r="#/components/schemas/";for(const n of Object.keys(e)){const o=e[n];w(o)||typeof o=="boolean"||(o["x-component-ref-path"]=r+n,typeof o!="boolean"&&o.discriminator&&!o.oneOf&&!o.anyOf&&this.discriminatingSchemas.add(r+n))}const i=(n,o)=>Object.values(n.mapping||{}).includes(o);for(const n of Object.keys(e)){const o=e[n];if(!(w(o)||typeof o=="boolean"||!o.allOf))for(const s of o.allOf){if(!w(s)||!this.discriminatingSchemas.has(s.$ref))continue;const f=e[U(s.$ref)].discriminator;i(f,r+n)||(f.mapping||(f.mapping={}),f.mapping[n]=r+n)}}}generateApi(){this.reset();const e=u.createSourceFile("ApiStub.ts",`/**
  * DO NOT MODIFY - This file has been generated using oazapfts.
  * See https://www.npmjs.com/package/oazapfts
  */
diff --git a/tscodegen-wH2Xseqv.js b/tscodegen-wH2Xseqv.js
index 34d4c8bec14db31c280d2988752cc32d9c5b3083..3367bb7bb97a88a6b662c13a125220d7b05392e8 100644
--- a/tscodegen-wH2Xseqv.js
+++ b/tscodegen-wH2Xseqv.js
@@ -474,7 +474,7 @@ class st {
         )
       ), o.createIntersectionTypeNode(r);
     }
-    return "items" in e ? o.createArrayTypeNode(
+    return "items" in e && typeof e.items === 'object' ? o.createArrayTypeNode(
       this.getTypeFromSchema(e.items, void 0, i)
     ) : "prefixItems" in e && e.prefixItems ? o.createTupleTypeNode(
       e.prefixItems.map((r) => this.getTypeFromSchema(r))
@@ -582,7 +582,8 @@ class st {
         return { readOnly: !1, writeOnly: !1 };
       let u = r.readOnly ?? !1, f = r.writeOnly ?? !1;
       const p = [];
-      "items" in r && r.items ? p.push(r.items) : (p.push(...Object.values(r.properties ?? {})), p.push(...r.allOf ?? []), p.push(...r.anyOf ?? []), p.push(...r.oneOf ?? []));
+      "items" in r && r.items && typeof r.items === 'object' ? p.push(r.items) : (p.push(...Object.values(r.properties ?? {})), p.push(...r.allOf ?? []), p.push(...r.anyOf ?? []), p.push(...r.oneOf ?? []));
+    //   "items" in r && r.items ? p.push(r.items) : (p.push(...Object.values(r.properties ?? {})), p.push(...r.allOf ?? []), p.push(...r.anyOf ?? []), p.push(...r.oneOf ?? []));
       for (const d of p) {
         if (u && f)
           break;
