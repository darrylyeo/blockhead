# =============================================================================
# Scalars
# =============================================================================

scalar BigInt

scalar Address
scalar Hash

scalar DateTime
scalar TokenAmount
scalar UsdAmount

scalar Percentage
scalar BasisPoints


# =============================================================================
# Entities
# =============================================================================

enum EntityType {
	Actor
	App
	Balance
	Block
	Contract
	Event
	Network
	Nft
	Storage
	Token
	Trace
	Transaction
	Transfer
	Validator
}

union Entity = 
	  Actor_Eoa 
	| Actor_Contract
	| App
	| Balance_Erc1155
	| Balance_Erc20 
	| Balance_Erc721 
	| Balance_Native 
	| Block_Canonical 
	| Block_Orphaned 
	| Block_Pending
	| Block_Uncle 
	| Contract 
	| Event_Approval 
	| Event_Custom
	| Event_Swap 
	| Event_Transfer 
	| Network 
	| Nft 
	| Storage 
	| Token_Erc1155
	| Token_Erc20 
	| Token_Erc721 
	| Token_Native 
	| Trace 
	| Transaction 
	| Transfer 
	| Validator 


# =============================================================================
# Actor
# =============================================================================

enum ActorType {
	Eoa
	Contract
}

enum ContractTag {
	System
	Multisig
	Proxy
	Factory
	Token
	Exchange
	Bridge
	Oracle
	Governance
	Treasury
	Registry
	Router
	Vault
	Staking
	Dao
	Marketplace
	Launchpad
}

enum ProxyType {
	Eip1967
	Eip1822
	Eip897
	Beacon
	Diamond
	Minimal
	Clone
}

type ActorLabel {
	name: String!
	source: String!
	verified: Boolean!
}

type AuditReport {
	auditor: String!
	date: BigInt!
	reportUrl: String!
	score: Int
}

interface Actor_Base {
	type: ActorType!
	address: Address!
	chainId: Int!
	labels: [ActorLabel!]
	balance: TokenAmount
	balanceUsd: UsdAmount
	firstSeenAt: BigInt
	lastActiveAt: BigInt
	transactionCount: Int
	internalTransactionCount: Int
	riskLevel: String
	securityScore: Int
	auditReports: [AuditReport!]
	transactions(
		limit: Int = 100
		offset: Int = 0
		startTimestamp: BigInt
		endTimestamp: BigInt
		type: TransactionFormat
		status: TransactionStatus
		category: TransactionCategory
	): [Transaction!]!
	_relatedContracts: [Actor_Contract!]
	_createdContracts: [Actor_Contract!]
	_controlledBy: Actor
	_controls: [Actor!]
	_creator: Actor
	_implementation: Actor_Contract
	_admin: Actor
	_templateContract: Actor_Contract
}

type Actor_Eoa implements Actor_Base {
	type: ActorType!
	address: Address!
	chainId: Int!
	labels: [ActorLabel!]
	balance: TokenAmount
	balanceUsd: UsdAmount
	firstSeenAt: BigInt
	lastActiveAt: BigInt
	transactionCount: Int
	internalTransactionCount: Int
	riskLevel: String
	securityScore: Int
	auditReports: [AuditReport!]
	transactions(
		limit: Int = 100
		offset: Int = 0
		startTimestamp: BigInt
		endTimestamp: BigInt
		type: TransactionFormat
		status: TransactionStatus
		category: TransactionCategory
	): [Transaction!]!
	_relatedContracts: [Actor_Contract!]
	_createdContracts: [Actor_Contract!]
	_controlledBy: Actor
	_controls: [Actor!]
	_creator: Actor
	_implementation: Actor_Contract
	_admin: Actor
	_templateContract: Actor_Contract

	nonce: Int
	ensName: String
	ensAvatar: String
	ensReverse: String
	isVerified: Boolean
	tags: [String!]
	averageGasPrice: String
	preferredGasLimit: String
}

type Actor_Contract implements Actor_Base {
	type: ActorType!
	address: Address!
	chainId: Int!
	labels: [ActorLabel!]
	balance: TokenAmount
	balanceUsd: UsdAmount
	firstSeenAt: BigInt
	lastActiveAt: BigInt
	transactionCount: Int
	internalTransactionCount: Int
	riskLevel: String
	securityScore: Int
	auditReports: [AuditReport!]
	transactions(
		limit: Int = 100
		offset: Int = 0
		startTimestamp: BigInt
		endTimestamp: BigInt
		type: TransactionFormat
		status: TransactionStatus
		category: TransactionCategory
	): [Transaction!]!
	_relatedContracts: [Actor_Contract!]
	_createdContracts: [Actor_Contract!]
	_controlledBy: Actor
	_controls: [Actor!]
	_creator: Actor
	_implementation: Actor_Contract
	_admin: Actor
	_templateContract: Actor_Contract

	bytecode: Hash
	creationTransaction: Hash
	creationBlock: Int
	bytecodeSize: Int
	hasSource: Boolean
	verificationDate: BigInt
	verificationMethod: String
	contractTags: [ContractTag!]
	standards: [ContractStandard!]
	proxyType: ProxyType
	isUpgradable: Boolean
	protocolName: String
	protocolVersion: String
	protocolRole: String
}

union Actor = Actor_Eoa | Actor_Contract

fragment Actor_Fragment on Actor {
	type
	address
	chainId
	labels {
		name
		source
		verified
	}
	balance
	balanceUsd
	firstSeenAt
	lastActiveAt
	transactionCount
	internalTransactionCount
	riskLevel
	securityScore
	auditReports {
		auditor
		date
		reportUrl
		score
	}
	transactions(limit: 10) {
		id
		timestamp
		value
		gasUsed
		isSuccess
		status
		categories
		from
		to
	}
	... on Actor_Eoa {
		nonce
		ensName
		ensAvatar
		ensReverse
		isVerified
		tags
		averageGasPrice
		preferredGasLimit
	}
	... on Actor_Contract {
		bytecode
		creationTransaction
		creationBlock
		bytecodeSize
		hasSource
		verificationDate
		verificationMethod
		contractTags
		standards
		proxyType
		isUpgradable
		protocolName
		protocolVersion
		protocolRole
	}
}


# =============================================================================
# App
# =============================================================================

type App {
	slug: String!
	name: String!
	icon: String
	colors: [String!]
	links: [String!]
}

fragment App_Fragment on App {
	slug
	name
	icon
	colors
	links
}


# =============================================================================
# Balance
# =============================================================================

enum BalanceType {
	Available
	Locked
	Staked
	Delegated
	Vesting
	Escrow
	Collateral
	Pending
}

enum BalanceCategory {
	Wallet
	Contract
	Defi
	Cex
	Gaming
	Dao
	Multisig
	Bridge
}

interface Balance_Base {
	id: String!
	chainId: Int!
	standard: TokenStandard!
	types: [BalanceType!]!
	category: BalanceCategory!
	balance: TokenAmount!
	balanceUsd: UsdAmount
	blockNumber: BigInt!
	timestamp: BigInt!
	isActive: Boolean!
	lastActivity: BigInt
	transactionCount: Int
	changeAmount: TokenAmount
	changePercentage: Percentage
	changePeriod: String
	riskLevel: String
	securityFlags: [String!]
	isVerified: Boolean
	_owner: Actor
	_asset: Token
	_protocol: App
	_liquidityPool: Contract
	_stakingContract: Contract
	_validator: Actor
	_vestingContract: Contract
	_relatedBalances: [Balance!]
	_recentTransactions: [Transaction!]
	_recentTransfers: [Transfer!]
}

type Balance_Native implements Balance_Base {
	id: String!
	chainId: Int!
	standard: TokenStandard!
	types: [BalanceType!]!
	category: BalanceCategory!
	balance: TokenAmount!
	balanceUsd: UsdAmount
	blockNumber: BigInt!
	timestamp: BigInt!
	isActive: Boolean!
	lastActivity: BigInt
	transactionCount: Int
	changeAmount: TokenAmount
	changePercentage: Percentage
	changePeriod: String
	riskLevel: String
	securityFlags: [String!]
	isVerified: Boolean
	_owner: Actor
	_asset: Token
	_protocol: App
	_liquidityPool: Contract
	_stakingContract: Contract
	_validator: Actor
	_vestingContract: Contract
	_relatedBalances: [Balance!]
	_recentTransactions: [Transaction!]
	_recentTransfers: [Transfer!]

	symbol: String!
	decimals: Int!
	networkName: String!
	availableForGas: TokenAmount!
	reservedForGas: TokenAmount
	totalStaked: TokenAmount
	stakingRewards: TokenAmount
	validatorAddress: Address
	delegationRewards: TokenAmount
	commission: Percentage
	governanceVotes: Int
	proposalParticipation: Percentage
}

type Balance_Erc20 implements Balance_Base {
	id: String!
	chainId: Int!
	standard: TokenStandard!
	types: [BalanceType!]!
	category: BalanceCategory!
	balance: TokenAmount!
	balanceUsd: UsdAmount
	blockNumber: BigInt!
	timestamp: BigInt!
	isActive: Boolean!
	lastActivity: BigInt
	transactionCount: Int
	changeAmount: TokenAmount
	changePercentage: Percentage
	changePeriod: String
	riskLevel: String
	securityFlags: [String!]
	isVerified: Boolean
	_owner: Actor
	_asset: Token
	_protocol: App
	_liquidityPool: Contract
	_stakingContract: Contract
	_validator: Actor
	_vestingContract: Contract
	_relatedBalances: [Balance!]
	_recentTransactions: [Transaction!]
	_recentTransfers: [Transfer!]

	name: String!
	symbol: String!
	decimals: Int!
	totalSupply: TokenAmount
	holderRank: Int
	holderPercentage: Percentage
	liquidityAvailable: Boolean!
}

type Balance_Erc721 implements Balance_Base {
	id: String!
	chainId: Int!
	standard: TokenStandard!
	types: [BalanceType!]!
	category: BalanceCategory!
	balance: TokenAmount!
	balanceUsd: UsdAmount
	blockNumber: BigInt!
	timestamp: BigInt!
	isActive: Boolean!
	lastActivity: BigInt
	transactionCount: Int
	changeAmount: TokenAmount
	changePercentage: Percentage
	changePeriod: String
	riskLevel: String
	securityFlags: [String!]
	isVerified: Boolean
	_owner: Actor
	_asset: Token
	_protocol: App
	_liquidityPool: Contract
	_stakingContract: Contract
	_validator: Actor
	_vestingContract: Contract
	_relatedBalances: [Balance!]
	_recentTransactions: [Transaction!]
	_recentTransfers: [Transfer!]

	tokenIds: [String!]!
	collectionName: String!
	collectionSymbol: String!
	totalSupply: Int
	ownershipPercentage: Percentage
	floorPrice: UsdAmount
	totalValue: UsdAmount
	averageHoldingTime: Int
	realizationRate: Percentage
}

type Balance_Erc1155 implements Balance_Base {
	id: String!
	chainId: Int!
	standard: TokenStandard!
	types: [BalanceType!]!
	category: BalanceCategory!
	balance: TokenAmount!
	balanceUsd: UsdAmount
	blockNumber: BigInt!
	timestamp: BigInt!
	isActive: Boolean!
	lastActivity: BigInt
	transactionCount: Int
	changeAmount: TokenAmount
	changePercentage: Percentage
	changePeriod: String
	riskLevel: String
	securityFlags: [String!]
	isVerified: Boolean
	_owner: Actor
	_asset: Token
	_protocol: App
	_liquidityPool: Contract
	_stakingContract: Contract
	_validator: Actor
	_vestingContract: Contract
	_relatedBalances: [Balance!]
	_recentTransactions: [Transaction!]
	_recentTransfers: [Transfer!]

	uniqueTokens: Int!
	totalTokens: TokenAmount!
	fungibleValue: UsdAmount!
	nftValue: UsdAmount!
	totalValue: UsdAmount!
}

union Balance = Balance_Native | Balance_Erc20 | Balance_Erc721 | Balance_Erc1155

fragment Balance_Fragment on Balance {
	id
	chainId
	standard
	types
	category
	balance
	balanceUsd
	blockNumber
	timestamp
	isActive
	lastActivity
	transactionCount
	changeAmount
	changePercentage
	changePeriod
	riskLevel
	securityFlags
	isVerified
	... on Balance_Native {
		symbol
		decimals
		networkName
		availableForGas
		reservedForGas
		totalStaked
		stakingRewards
		validatorAddress
		delegationRewards
		commission
		governanceVotes
		proposalParticipation
	}
	... on Balance_Erc20 {
		name
		symbol
		decimals
		totalSupply
		holderRank
		holderPercentage
		liquidityAvailable
	}
	... on Balance_Erc721 {
		tokenIds
		collectionName
		collectionSymbol
		totalSupply
		ownershipPercentage
		floorPrice
		totalValue
		averageHoldingTime
		realizationRate
	}
	... on Balance_Erc1155 {
		uniqueTokens
		totalTokens
		fungibleValue
		nftValue
		totalValue
	}
}


# =============================================================================
# Block
# =============================================================================

enum BlockRole {
	Canonical
	Uncle
	Orphaned
	Pending
}

enum BlockStatus {
	Pending
	Confirmed
	Finalized
	Reorged
}

enum ConsensusType {
	Pow
	Pos
	Poa
	PoaClique
	PoaBor
	PoaIbft
	PoaAura
	Tendermint
	Layer2Sequencer
	Rollup
}

type BlockCharacteristics {
	isGenesis: Boolean!
	isEmpty: Boolean!
	isFork: Boolean!
	isMerge: Boolean!
	isShanghai: Boolean!
	isCancun: Boolean!
	isDencun: Boolean!
	hasUncles: Boolean!
	hasReorg: Boolean!
	hasBlobs: Boolean!
	hasBeaconRoots: Boolean!
	hasWithdrawals: Boolean!
}

type CompetingBlock {
	hash: Hash!
	miner: Address!
	totalDifficulty: String
}

interface Block_Base {
	chainId: Int!
	blockNumber: BigInt!
	blockHash: Hash!
	role: BlockRole!
	status: BlockStatus!
	characteristics: BlockCharacteristics!
	timestamp: BigInt!
	parentHash: Hash!
	stateRoot: Hash!
	transactionsRoot: Hash!
	receiptsRoot: Hash!
	consensusType: ConsensusType!
	difficulty: String
	totalDifficulty: String
	nonce: String
	extraData: String
	size: Int!
	gasLimit: TokenAmount!
	gasUsed: TokenAmount
	gasUsedPercentage: Percentage!
	transactionCount: Int!
	internalTransactionCount: Int
	baseFeePerGas: TokenAmount
	burntFees: TokenAmount
	minerReward: TokenAmount
	minedAt: BigInt!
	receivedAt: BigInt
	propagationTime: Int
	_miner: Actor
	_sequencer: Actor
	_parentBlock: Block
	_childBlocks: [Block!]
	_uncleBlocks: [Block_Uncle!]
	_transactions: [Transaction!]
	_events: [Event!]
	_validator: Validator
}

type Block_Canonical implements Block_Base {
	chainId: Int!
	blockNumber: BigInt!
	blockHash: Hash!
	role: BlockRole!
	status: BlockStatus!
	characteristics: BlockCharacteristics!
	timestamp: BigInt!
	parentHash: Hash!
	stateRoot: Hash!
	transactionsRoot: Hash!
	receiptsRoot: Hash!
	consensusType: ConsensusType!
	difficulty: String
	totalDifficulty: String
	nonce: String
	extraData: String
	size: Int!
	gasLimit: TokenAmount!
	gasUsed: TokenAmount
	gasUsedPercentage: Percentage!
	transactionCount: Int!
	internalTransactionCount: Int
	baseFeePerGas: TokenAmount
	burntFees: TokenAmount
	minerReward: TokenAmount
	minedAt: BigInt!
	receivedAt: BigInt
	propagationTime: Int
	_miner: Actor
	_sequencer: Actor
	_parentBlock: Block
	_childBlocks: [Block!]
	_uncleBlocks: [Block_Uncle!]
	_transactions: [Transaction!]
	_events: [Event!]
	_validator: Validator

	confirmations: Int!
	isFinalized: Boolean!
	chainTipDistance: Int!
	cumulativeGasUsed: TokenAmount
	cumulativeDifficulty: String
}

type Block_Uncle implements Block_Base {
	chainId: Int!
	blockNumber: BigInt!
	blockHash: Hash!
	role: BlockRole!
	status: BlockStatus!
	characteristics: BlockCharacteristics!
	timestamp: BigInt!
	parentHash: Hash!
	stateRoot: Hash!
	transactionsRoot: Hash!
	receiptsRoot: Hash!
	consensusType: ConsensusType!
	difficulty: String
	totalDifficulty: String
	nonce: String
	extraData: String
	size: Int!
	gasLimit: TokenAmount!
	gasUsed: TokenAmount
	gasUsedPercentage: Percentage!
	transactionCount: Int!
	internalTransactionCount: Int
	baseFeePerGas: TokenAmount
	burntFees: TokenAmount
	minerReward: TokenAmount
	minedAt: BigInt!
	receivedAt: BigInt
	propagationTime: Int
	_miner: Actor
	_sequencer: Actor
	_parentBlock: Block
	_childBlocks: [Block!]
	_uncleBlocks: [Block_Uncle!]
	_transactions: [Transaction!]
	_events: [Event!]
	_validator: Validator

	unclePosition: Int!
	uncleHash: Hash!
	nephewHash: Hash!
	nephewNumber: BigInt!
	uncleMiner: Address!
	uncleReward: TokenAmount!
	uncleHeight: Int!
	inclusionDelay: Int!
}

type Block_Orphaned implements Block_Base {
	chainId: Int!
	blockNumber: BigInt!
	blockHash: Hash!
	role: BlockRole!
	status: BlockStatus!
	characteristics: BlockCharacteristics!
	timestamp: BigInt!
	parentHash: Hash!
	stateRoot: Hash!
	transactionsRoot: Hash!
	receiptsRoot: Hash!
	consensusType: ConsensusType!
	difficulty: String
	totalDifficulty: String
	nonce: String
	extraData: String
	size: Int!
	gasLimit: TokenAmount!
	gasUsed: TokenAmount
	gasUsedPercentage: Percentage!
	transactionCount: Int!
	internalTransactionCount: Int
	baseFeePerGas: TokenAmount
	burntFees: TokenAmount
	minerReward: TokenAmount
	minedAt: BigInt!
	receivedAt: BigInt
	propagationTime: Int
	_miner: Actor
	_sequencer: Actor
	_parentBlock: Block
	_childBlocks: [Block!]
	_uncleBlocks: [Block_Uncle!]
	_transactions: [Transaction!]
	_events: [Event!]
	_validator: Validator

	orphanedReason: String!
	canonicalBlockHash: Hash
	forkLength: Int
	competingBlocks: [CompetingBlock!]
}

type Block_Pending implements Block_Base {
	chainId: Int!
	blockNumber: BigInt!
	blockHash: Hash!
	role: BlockRole!
	status: BlockStatus!
	characteristics: BlockCharacteristics!
	timestamp: BigInt!
	parentHash: Hash!
	stateRoot: Hash!
	transactionsRoot: Hash!
	receiptsRoot: Hash!
	consensusType: ConsensusType!
	difficulty: String
	totalDifficulty: String
	nonce: String
	extraData: String
	size: Int!
	gasLimit: TokenAmount!
	gasUsed: TokenAmount
	gasUsedPercentage: Percentage!
	transactionCount: Int!
	internalTransactionCount: Int
	baseFeePerGas: TokenAmount
	burntFees: TokenAmount
	minerReward: TokenAmount
	minedAt: BigInt!
	receivedAt: BigInt
	propagationTime: Int
	_miner: Actor
	_sequencer: Actor
	_parentBlock: Block
	_childBlocks: [Block!]
	_uncleBlocks: [Block_Uncle!]
	_transactions: [Transaction!]
	_events: [Event!]
	_validator: Validator

	estimatedConfirmationTime: Int
	replacementRisk: Percentage
	mempoolEntryTime: BigInt
	priorityScore: Int
}

union Block = Block_Canonical | Block_Uncle | Block_Orphaned | Block_Pending

fragment Block_Fragment on Block {
	chainId
	blockNumber
	blockHash
	role
	status
	characteristics {
		isGenesis
		isEmpty
		isFork
		isMerge
		isShanghai
		isCancun
		isDencun
		hasUncles
		hasReorg
		hasBlobs
		hasBeaconRoots
		hasWithdrawals
	}
	timestamp
	parentHash
	stateRoot
	transactionsRoot
	receiptsRoot
	consensusType
	difficulty
	totalDifficulty
	nonce
	extraData
	size
	gasLimit
	gasUsed
	gasUsedPercentage
	transactionCount
	internalTransactionCount
	baseFeePerGas
	burntFees
	minerReward
	minedAt
	receivedAt
	propagationTime
	... on Block_Canonical {
		confirmations
		isFinalized
		chainTipDistance
		cumulativeGasUsed
		cumulativeDifficulty
	}
	... on Block_Uncle {
		unclePosition
		uncleHash
		nephewHash
		nephewNumber
		uncleMiner
		uncleReward
		uncleHeight
		inclusionDelay
	}
	... on Block_Orphaned {
		orphanedReason
		canonicalBlockHash
		forkLength
		competingBlocks {
			hash
			miner
			totalDifficulty
		}
	}
	... on Block_Pending {
		estimatedConfirmationTime
		replacementRisk
		mempoolEntryTime
		priorityScore
	}
}


# =============================================================================
# Contract
# =============================================================================

enum ContractStandard {
	Custom
	Erc20
	Erc721
	Erc1155
	Erc4626
	Erc1967
	Erc2535
	Erc4337
	Erc6551
}

enum ContractCategory {
	Token
	Nft
	Defi
	Gaming
	Governance
	Infrastructure
	Bridge
	Oracle
	Identity
	Storage
	Proxy
	Factory
	Multisig
	Account
	Utility
}

type Contract {
	address: Address!
	chainId: Int!
	standards: [ContractStandard!]!
	categories: [ContractCategory!]!
	name: String
	version: String
	bytecode: Hash!
	sourceCode: String
	compilerVersion: String
	optimizationEnabled: Boolean
	deploymentTransaction: Hash!
	deploymentBlock: BigInt!
	deploymentTimestamp: BigInt!
	_contractActor: Actor_Contract
	_deployer: Actor
	_owner: Actor
	_admin: Actor
	_implementation: Contract
	_beacon: Contract
	_factory: Actor_Contract
	_createdContracts: [Contract!]
	_relatedContracts: [Contract!]
	_dependsOn: [Contract!]
	_dependents: [Contract!]
	_frequentCallers: [Actor!]
	_recentTransactions: [Transaction!]
	_events: [Event!]
}

fragment Contract_Fragment on Contract {
	address
	chainId
	standards
	categories
	name
	version
	bytecode
	sourceCode
	compilerVersion
	optimizationEnabled
	deploymentTransaction
	deploymentBlock
	deploymentTimestamp
}


# =============================================================================
# Event
# =============================================================================

enum EventCategory {
	Transfer
	Approval
	Mint
	Burn
	Swap
	Liquidity
	Lending
	Staking
	Governance
	Bridge
	Oracle
	System
	Custom
}

enum EventSeverity {
	Info
	Warning
	Error
	Critical
}

interface Event_Base {
	id: String!
	chainId: Int!
	category: EventCategory!
	severity: EventSeverity!
	blockNumber: BigInt!
	blockHash: Hash!
	transactionHash: Hash!
	transactionIndex: Int!
	logIndex: Int!
	topics: [Hash!]!
	data: String!
	eventSignature: String
	eventName: String
	removed: Boolean!
	timestamp: BigInt!
	decodedData: String
	decodedTopics: String
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	effectiveGasPrice: TokenAmount
	_emitter: Contract
	_transaction: Transaction
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedEvents: [Event!]
	_triggeredEvents: [Event!]
	_token: Token
	_nft: Nft
}

type Event_Transfer implements Event_Base {
	id: String!
	chainId: Int!
	category: EventCategory!
	severity: EventSeverity!
	blockNumber: BigInt!
	blockHash: Hash!
	transactionHash: Hash!
	transactionIndex: Int!
	logIndex: Int!
	topics: [Hash!]!
	data: String!
	eventSignature: String
	eventName: String
	removed: Boolean!
	timestamp: BigInt!
	decodedData: String
	decodedTopics: String
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	effectiveGasPrice: TokenAmount
	_emitter: Contract
	_transaction: Transaction
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedEvents: [Event!]
	_triggeredEvents: [Event!]
	_token: Token
	_nft: Nft

	transferType: String!
	from: Address!
	to: Address!
	tokenAddress: Address
	tokenSymbol: String
	amount: TokenAmount
	tokenId: String
	tokenIds: [String!]
	amounts: [TokenAmount!]
	valueUsd: UsdAmount
	pricePerToken: UsdAmount
	isInternal: Boolean
	isMint: Boolean
	isBurn: Boolean
	transferFee: TokenAmount
	taxAmount: TokenAmount
	netAmount: TokenAmount
}

type Event_Swap implements Event_Base {
	id: String!
	chainId: Int!
	category: EventCategory!
	severity: EventSeverity!
	blockNumber: BigInt!
	blockHash: Hash!
	transactionHash: Hash!
	transactionIndex: Int!
	logIndex: Int!
	topics: [Hash!]!
	data: String!
	eventSignature: String
	eventName: String
	removed: Boolean!
	timestamp: BigInt!
	decodedData: String
	decodedTopics: String
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	effectiveGasPrice: TokenAmount
	_emitter: Contract
	_transaction: Transaction
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedEvents: [Event!]
	_triggeredEvents: [Event!]
	_token: Token
	_nft: Nft

	swapType: String!
	sender: Address!
	recipient: Address!
	tokenIn: Address!
	tokenOut: Address!
	amountIn: TokenAmount!
	amountOut: TokenAmount!
	tokenInSymbol: String
	tokenOutSymbol: String
	tokenInDecimals: Int
	tokenOutDecimals: Int
	priceImpact: Percentage
	executionPrice: Float
	spotPrice: Float
	slippage: Percentage
	amountInUsd: UsdAmount
	amountOutUsd: UsdAmount
	poolAddress: Address
	poolFee: BasisPoints
	route: [Address!]
	isPrivate: Boolean
	hasAntiMev: Boolean
}

type Event_Approval implements Event_Base {
	id: String!
	chainId: Int!
	category: EventCategory!
	severity: EventSeverity!
	blockNumber: BigInt!
	blockHash: Hash!
	transactionHash: Hash!
	transactionIndex: Int!
	logIndex: Int!
	topics: [Hash!]!
	data: String!
	eventSignature: String
	eventName: String
	removed: Boolean!
	timestamp: BigInt!
	decodedData: String
	decodedTopics: String
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	effectiveGasPrice: TokenAmount
	_emitter: Contract
	_transaction: Transaction
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedEvents: [Event!]
	_triggeredEvents: [Event!]
	_token: Token
	_nft: Nft

	owner: Address!
	spender: Address!
	tokenAddress: Address!
	tokenSymbol: String
	amount: TokenAmount
	tokenId: String
	approved: Boolean
	isUnlimited: Boolean
	previousAllowance: TokenAmount
	expirationTime: BigInt
	riskLevel: String
	spenderType: String
}

type Event_Custom implements Event_Base {
	id: String!
	chainId: Int!
	category: EventCategory!
	severity: EventSeverity!
	blockNumber: BigInt!
	blockHash: Hash!
	transactionHash: Hash!
	transactionIndex: Int!
	logIndex: Int!
	topics: [Hash!]!
	data: String!
	eventSignature: String
	eventName: String
	removed: Boolean!
	timestamp: BigInt!
	decodedData: String
	decodedTopics: String
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	effectiveGasPrice: TokenAmount
	_emitter: Contract
	_transaction: Transaction
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedEvents: [Event!]
	_triggeredEvents: [Event!]
	_token: Token
	_nft: Nft

	eventType: String!
	protocol: String
	customData: String
}

union Event = Event_Transfer | Event_Swap | Event_Approval | Event_Custom

fragment Event_Fragment on Event {
	id
	chainId
	category
	severity
	blockNumber
	blockHash
	transactionHash
	transactionIndex
	logIndex
	topics
	data
	eventSignature
	eventName
	removed
	timestamp
	decodedData
	decodedTopics
	gasUsed
	gasPrice
	effectiveGasPrice
	... on Event_Transfer {
		transferType
		from
		to
		tokenAddress
		tokenSymbol
		amount
		tokenId
		tokenIds
		amounts
		valueUsd
		pricePerToken
		isInternal
		isMint
		isBurn
		transferFee
		taxAmount
		netAmount
	}
	... on Event_Swap {
		swapType
		sender
		recipient
		tokenIn
		tokenOut
		amountIn
		amountOut
		tokenInSymbol
		tokenOutSymbol
		tokenInDecimals
		tokenOutDecimals
		priceImpact
		executionPrice
		spotPrice
		slippage
		amountInUsd
		amountOutUsd
		poolAddress
		poolFee
		route
		isPrivate
		hasAntiMev
	}
	... on Event_Approval {
		owner
		spender
		tokenAddress
		tokenSymbol
		amount
		tokenId
		approved
		isUnlimited
		previousAllowance
		expirationTime
		riskLevel
		spenderType
	}
	... on Event_Custom {
		eventType
		protocol
		customData
	}
}


# =============================================================================
# Network
# =============================================================================

enum NetworkType {
	Mainnet
	Testnet
	Devnet
	Layer2
	Sidechain
	PrivateNetwork
	Rollup
	Subnet
}

enum NetworkStatus {
	Active
	Deprecated
	Maintenance
	Halted
	Beta
	Alpha
}

enum RollupType {
	Optimistic
	ZKRollup
	Validium
	Plasma
	StateChannel
}

type Network {
	chainId: Int!
	name: String!
	status: NetworkStatus!
	type: NetworkType!
}

fragment Network_Fragment on Network {
	chainId
	name
	status
	type
}


# =============================================================================
# NFT
# =============================================================================

enum NftStandard {
	Erc721
	Erc1155
	Erc998
	Erc4907
	Erc5192
	CryptoKitties
	CryptoPunks
	Ens
	Other
}

enum NftCategory {
	Art
	Collectible
	Gaming
	Utility
	Domain
	Music
	Video
	Photography
	Sports
	VirtualWorlds
	Membership
	Identity
	Other
}

enum NftRarity {
	Common
	Uncommon
	Rare
	Epic
	Legendary
	Mythic
	Unique
}

type NftAttribute {
	traitType: String!
	value: String!
	displayType: String
	maxValue: Int
	rarity: Percentage
}

type NftMetadata {
	name: String
	description: String
	image: String
	imagePreview: String
	imageThumbnail: String
	imageOriginal: String
	animationUrl: String
	animationOriginal: String
	externalUrl: String
	backgroundColor: String
	attributes: [NftAttribute!]
	tokenUri: String
	metadataUri: String
	contractUri: String
}

type Nft {
	contractAddress: Address!
	tokenId: String!
	chainId: Int!
	standard: NftStandard!
	categories: [NftCategory!]!
	metadata: NftMetadata!
	rarity: NftRarity
	rarityScore: Int
	rarityRank: Int
	_collection: Contract
	_creator: Actor
	_owner: Actor
	_minter: Actor
	_mintTransaction: Transaction
}

fragment Nft_Fragment on Nft {
	contractAddress
	tokenId
	chainId
	standard
	categories
	metadata {
		name
		description
		image
		imagePreview
		imageThumbnail
		imageOriginal
		animationUrl
		animationOriginal
		externalUrl
		backgroundColor
		attributes {
			traitType
			value
			displayType
			maxValue
			rarity
		}
		tokenUri
		metadataUri
		contractUri
	}
	rarity
	rarityScore
	rarityRank
}


# =============================================================================
# Storage
# =============================================================================

enum StorageOperation {
	Read
	Write
	Create
	Delete
	WarmRead
	ColdRead
}

enum StorageContext {
	Transaction
	StateAccess
	Proof
	Migration
	Backup
	Recovery
}

enum StorageGranularity {
	Slot
	Contract
	Block
	State
}

type Storage {
	id: String!
	chainId: Int!
	operation: StorageOperation!
	context: StorageContext!
	granularity: StorageGranularity!
	storageSlot: Hash!
	blockNumber: BigInt!
	timestamp: BigInt!
	value: Hash!
	_contract: Contract
	_block: Block
	_transaction: Transaction
	_trace: Trace
	_accessor: Actor
	_relatedOperations: [Storage!]
	_dependencies: [Storage!]
	_events: [Event!]
}

fragment Storage_Fragment on Storage {
	id
	chainId
	operation
	context
	granularity
	storageSlot
	blockNumber
	timestamp
	value
}


# =============================================================================
# Token
# =============================================================================

enum TokenStandard {
	Native
	Erc20
	Erc721
	Erc1155
	Erc4626
}

enum TokenType {
	Utility
	Governance
	Stablecoin
	Wrapped
	Synthetic
	Rebasing
	Deflationary
	Yield
	Lp
	Receipt
	Collectible
	Art
	Gaming
	Membership
	Identity
}

type TokenMetadata {
	address: Address!
	chainId: Int!
	name: String!
	symbol: String!
	decimals: Int!
	logoUri: String
	tags: [String!]!
}

type TokenMechanics {
	isMintable: Boolean!
	isBurnable: Boolean!
	isPausable: Boolean!
	hasPermissions: Boolean!
	isUpgradable: Boolean!
	transferTax: Percentage
	burnRate: Percentage
	reflectionRate: Percentage
	inflationRate: Percentage
}

type TokenVerification {
	isVerified: Boolean!
	verificationSource: String
	securityScore: Int
	auditReports: [AuditReport!]
	riskLevel: String!
	riskFactors: [String!]!
}

type MultiTokenTypes {
	fungible: Int!
	nonFungible: Int!
	semiFungible: Int!
}

interface Token_Base {
	address: Address!
	chainId: Int!
	standard: TokenStandard!
	types: [TokenType!]!
	metadata: TokenMetadata!
	decimals: Int!
	totalSupply: TokenAmount
	maxSupply: TokenAmount
	mechanics: TokenMechanics
	verification: TokenVerification!
	holderCount: Int
	_contractActor: Actor_Contract
	_creator: Actor
	_owner: Actor
	_deployer: Actor
	_admin: Actor
	_minters: [Actor!]
	_burners: [Actor!]
	_topHolders: [Actor!]
	_recentTransfers: [Transfer!]
	_creationTransaction: Transaction
}

type Token_Native implements Token_Base {
	address: Address!
	chainId: Int!
	standard: TokenStandard!
	types: [TokenType!]!
	metadata: TokenMetadata!
	decimals: Int!
	totalSupply: TokenAmount
	maxSupply: TokenAmount
	mechanics: TokenMechanics
	verification: TokenVerification!
	holderCount: Int
	_contractActor: Actor_Contract
	_creator: Actor
	_owner: Actor
	_deployer: Actor
	_admin: Actor
	_minters: [Actor!]
	_burners: [Actor!]
	_topHolders: [Actor!]
	_recentTransfers: [Transfer!]
	_creationTransaction: Transaction

	networkName: String!
	consensusType: String!
	blockTime: Int!
	gasTokenUsage: Boolean!
	issuanceModel: String!
	annualInflation: Percentage
}

type Token_Erc20 implements Token_Base {
	address: Address!
	chainId: Int!
	standard: TokenStandard!
	types: [TokenType!]!
	metadata: TokenMetadata!
	decimals: Int!
	totalSupply: TokenAmount
	maxSupply: TokenAmount
	mechanics: TokenMechanics
	verification: TokenVerification!
	holderCount: Int
	_contractActor: Actor_Contract
	_creator: Actor
	_owner: Actor
	_deployer: Actor
	_admin: Actor
	_minters: [Actor!]
	_burners: [Actor!]
	_topHolders: [Actor!]
	_recentTransfers: [Transfer!]
	_creationTransaction: Transaction

	name: String!
	symbol: String!
	mintable: Boolean!
	burnable: Boolean!
	pausable: Boolean!
	upgradeable: Boolean!
	permit: Boolean!
	flashMintable: Boolean!
	deflationary: Boolean!
	rebasable: Boolean!
	taxToken: Boolean!
}

type Token_Erc721 implements Token_Base {
	address: Address!
	chainId: Int!
	standard: TokenStandard!
	types: [TokenType!]!
	metadata: TokenMetadata!
	decimals: Int!
	totalSupply: TokenAmount
	maxSupply: TokenAmount
	mechanics: TokenMechanics
	verification: TokenVerification!
	holderCount: Int
	_contractActor: Actor_Contract
	_creator: Actor
	_owner: Actor
	_deployer: Actor
	_admin: Actor
	_minters: [Actor!]
	_burners: [Actor!]
	_topHolders: [Actor!]
	_recentTransfers: [Transfer!]
	_creationTransaction: Transaction

	name: String!
	symbol: String!
	baseURI: String
	mintPrice: TokenAmount
	royaltyPercentage: Percentage
	isMintable: Boolean!
	publicMint: Boolean!
	whitelistMint: Boolean!
	floorPrice: TokenAmount
	totalVolume: TokenAmount
	uniqueOwners: Int!
}

type Token_Erc1155 implements Token_Base {
	address: Address!
	chainId: Int!
	standard: TokenStandard!
	types: [TokenType!]!
	metadata: TokenMetadata!
	decimals: Int!
	totalSupply: TokenAmount
	maxSupply: TokenAmount
	mechanics: TokenMechanics
	verification: TokenVerification!
	holderCount: Int
	_contractActor: Actor_Contract
	_creator: Actor
	_owner: Actor
	_deployer: Actor
	_admin: Actor
	_minters: [Actor!]
	_burners: [Actor!]
	_topHolders: [Actor!]
	_recentTransfers: [Transfer!]
	_creationTransaction: Transaction

	name: String
	uri: String!
	tokenCount: Int!
	tokenTypes: MultiTokenTypes!
	supportsBatchTransfer: Boolean!
	supportsBatchMint: Boolean!
}

union Token = Token_Native | Token_Erc20 | Token_Erc721 | Token_Erc1155

fragment Token_Fragment on Token {
	address
	chainId
	standard
	types
	metadata {
		address
		chainId
		name
		symbol
		decimals
		logoUri
		tags
	}
	decimals
	totalSupply
	maxSupply
	mechanics {
		isMintable
		isBurnable
		isPausable
		hasPermissions
		isUpgradable
		transferTax
		burnRate
		reflectionRate
		inflationRate
	}
	verification {
		isVerified
		verificationSource
		securityScore
		auditReports {
			auditor
			date
			reportUrl
			score
		}
		riskLevel
		riskFactors
	}
	holderCount
	... on Token_Native {
		networkName
		consensusType
		blockTime
		gasTokenUsage
		issuanceModel
		annualInflation
	}
	... on Token_Erc20 {
		name
		symbol
		mintable
		burnable
		pausable
		upgradeable
		permit
		flashMintable
		deflationary
		rebasable
		taxToken
	}
	... on Token_Erc721 {
		name
		symbol
		baseURI
		maxSupply
		mintPrice
		royaltyPercentage
		isMintable
		publicMint
		whitelistMint
		floorPrice
		totalVolume
		uniqueOwners
	}
	... on Token_Erc1155 {
		name
		uri
		tokenCount
		tokenTypes {
			fungible
			nonFungible
			semiFungible
		}
		supportsBatchTransfer
		supportsBatchMint
	}
}


# =============================================================================
# Trace
# =============================================================================

enum TraceType {
	Call
	Create
	Create2
	SelfDestruct
	Reward
	Genesis
}

type Trace {
	id: String!
	chainId: Int!
	transactionHash: Hash!
	traceAddress: [Int!]!
	subtraces: Int!
	type: String!
	from: Address!
	to: Address
	value: TokenAmount
	gas: TokenAmount
	gasUsed: TokenAmount
	input: String
	output: String
	error: String
	_block: Block
	_transaction: Transaction
	_fromActor: Actor
	_toActor: Actor
	_creatorActor: Actor
	_createdContract: Contract
	_selfDestructContract: Contract
	_refundRecipient: Actor
	_rewardRecipient: Actor
	_parentTrace: Trace
	_childTraces: [Trace!]
	_relatedTraces: [Trace!]
	_events: [Event!]
	_transfers: [Transfer!]
}

fragment Trace_Fragment on Trace {
	id
	chainId
	transactionHash
	traceAddress
	subtraces
	type
	from
	to
	value
	gas
	gasUsed
	input
	output
	error
}


# =============================================================================
# Transaction
# =============================================================================

enum TransactionFormat {
	Type0Legacy
	Type1AccessList
	Type2DynamicFee
	Type3Blob
}

enum TransactionStatus {
	Pending
	Included
	Confirmed
	Failed
	Dropped
}

enum TransactionCategory {
	Transfer
	TokenTransfer
	ContractCall
	ContractCreation
	Defi
}

type Transaction {
	id: Hash!
	chainId: Int!
	format: TransactionFormat!
	status: TransactionStatus!
	categories: [TransactionCategory!]!
	isSuccess: Boolean!
	timestamp: BigInt
	from: Address!
	to: Address
	value: TokenAmount
	nonce: Int!
	blockNumber: BigInt
	transactionIndex: Int
	gasLimit: TokenAmount
	gasUsed: TokenAmount
	gasPrice: TokenAmount
	maxFeePerGas: TokenAmount
	maxPriorityFeePerGas: TokenAmount
	baseFeePerGas: TokenAmount
	input: String
	error: String
	revertReason: String
	_block: Block
	_fromActor: Actor
	_toActor: Actor
	_relatedTransactions: [Transaction!]
	_replacedBy: Transaction
	_parentTransaction: Transaction
	_events: [Event!]
	_transfers: [Transfer!]
	_traces: [Trace!]
	_blobs: [String!]
	_createdContract: Contract
	_bridgeContract: Contract
	_l1Transaction: Transaction
	_l2Transaction: Transaction
	_targetContract: Contract
}

fragment Transaction_Fragment on Transaction {
	id
	chainId
	format
	status
	categories
	isSuccess
	timestamp
	from
	to
	value
	nonce
	blockNumber
	transactionIndex
	gasLimit
	gasUsed
	gasPrice
	maxFeePerGas
	maxPriorityFeePerGas
	baseFeePerGas
	input
	error
	revertReason
}


# =============================================================================
# Transfer
# =============================================================================

enum TransferStandard {
	Native
	Erc20
	Erc721
	Erc1155
}

enum TransferCategory {
	Transfer
	Mint
	Burn
}

type TransferTokenData {
	tokenAddress: Address!
	amount: String!
	amountFormatted: String!
	symbol: String!
	name: String!
	decimals: Int!
	amountUsd: UsdAmount
}

type TransferNftData {
	tokenAddress: Address!
	tokenId: String!
	collectionName: String!
	collectionSymbol: String!
}

type Transfer {
	id: String!
	chainId: Int!
	standard: TransferStandard!
	category: TransferCategory!
	blockNumber: BigInt!
	indexInBlock: Int!
	indexInTransaction: Int!
	timestamp: BigInt!
	transactionHash: Hash!
	blockHash: Hash
	from: Address!
	to: Address
	tokenData: TransferTokenData
	nftData: TransferNftData
	_fromActor: Actor
	_toActor: Actor
	_block: Block
	_transaction: Transaction
	_tokenContract: Token
	_nftCollection: Contract
	_protocolActor: Actor
	_marketplaceActor: Actor
	_relatedTransfers: [Transfer!]
	_parentTransfer: Transfer
	_childTransfers: [Transfer!]
	_events: [Event!]
}

fragment Transfer_Fragment on Transfer {
	id
	chainId
	standard
	category
	blockNumber
	indexInBlock
	indexInTransaction
	timestamp
	transactionHash
	blockHash
	from
	to
	tokenData {
		tokenAddress
		amount
		amountFormatted
		symbol
		name
		decimals
		amountUsd
	}
	nftData {
		tokenAddress
		tokenId
		collectionName
		collectionSymbol
	}
}


# =============================================================================
# Validator
# =============================================================================

type Validator {
	index: Int!
	chainId: Int!
	pubkey: String!
	withdrawalCredentials: String!
	effectiveBalance: TokenAmount!
	slashed: Boolean!
	activationEligibilityEpoch: BigInt
	activationEpoch: BigInt
	exitEpoch: BigInt
	withdrawableEpoch: BigInt
}

fragment Validator_Fragment on Validator {
	index
	chainId
	pubkey
	withdrawalCredentials
	effectiveBalance
	slashed
	activationEligibilityEpoch
	activationEpoch
	exitEpoch
	withdrawableEpoch
}


# =============================================================================
# Query
# =============================================================================

type Query {
	Entities(
		chainIds: [Int!]
		types: [EntityType!]
		limit: Int = 100
		offset: Int = 0
		startTimestamp: BigInt
		endTimestamp: BigInt
	): [Entity!]!

	Actor(address: Address!, chainId: Int!): Actor
	App(slug: String!): App
	Balance(address: Address!, chainId: Int!, tokenAddress: Address): Balance
	Block(identifier: String!, chainId: Int!): Block
	Contract(address: Address!, chainId: Int!): Contract
	Event(id: String!, chainId: Int!): Event
	Network(chainId: Int!): Network
	Nft(contractAddress: Address!, tokenId: String!, chainId: Int!): Nft
	Storage(contractAddress: Address!, storageSlot: Hash!, chainId: Int!): Storage
	Token(address: Address!, chainId: Int!): Token
	Trace(id: String!, chainId: Int!): Trace
	Transaction(hash: Hash!, chainId: Int!): Transaction
	Transfer(id: String!, chainId: Int!): Transfer
	Validator(index: Int!, chainId: Int!): Validator
}
