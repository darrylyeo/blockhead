<script lang="ts">
	// Constants/types
	import type { Ethereum } from '../data/networks/types'
	import type { AccountConnection } from '../state/account'
	import type { NetworkProvider } from '../data/networkProviders/types'
	import { networkProviderConfigByProvider } from '../data/networkProviders'
	import { walletsByType } from '../data/wallets'
	
	type Abi = $$Generic<Ethereum.Abi>
	type AbiMethod = Ethereum.AbiMethod<Abi>
	type SelectedAbiMethod = AbiMethod


	// Context
	import { preferences } from '../state/preferences'


	// Functions
	import { isReadable, isWritable, isReadableWithoutInputs } from '../utils/abi'


	// External state
	export let network: Ethereum.Network
	export let networkProvider: NetworkProvider
	export let publicClient: Ethereum.PublicClient
	export let contractAddress: Ethereum.ContractAddress
	export let contractName: string
	export let contractAbi: Abi = []

	// (Computed)
	$: readableMethods = contractAbi.filter(isReadable)
	$: readableMethodsWithoutInputs = readableMethods.filter(isReadableWithoutInputs)
	$: readableMethodsWithInputs = readableMethods.filter(method => !isReadableWithoutInputs(method))
	$: writableMethods = contractAbi.filter(isWritable)

	$: methodsByGroup = [
		{
			name: 'Variables',
			singularName: 'Variable',
			methods: readableMethodsWithoutInputs,
		},
		{
			name: 'Queries',
			singularName: 'Query',
			methods: readableMethodsWithInputs,
		},
		{
			name: 'Actions',
			singularName: 'Action',
			methods: writableMethods,
		},
	]


	// Internal state
	let selectedAccountConnection: AccountConnection | undefined

	let selectedMethod: SelectedAbiMethod
	$: selectedMethod ??= writableMethods.sort((a, b) => b.inputs.length - a.inputs.length)[0]

	let payableAmount = 0n

	type FlattenKeys<T> = {
		[K in keyof T]: `${K & string}/${keyof T[K] & string}`
	}[keyof T]

	let inputValues: {
		[K in FlattenKeys<{
			[
				Method in AbiMethod
				as
				Method['name']
			]: {
				[
					Index in Exclude<keyof Method['inputs'], keyof any[]>
					as
					Method['inputs'][Index] extends { name: string }
						? Method['inputs'][Index]['name']
						: Index
				]: Ethereum.AbiMethodArg<Abi, Method['name'], Index extends `${infer T extends number}` ? T : never>
			}
		}>]?: string;
	} = {}

	$: contractMethod = selectedMethod
	$: contractMethodArgs = contractMethod?.inputs?.map((input, i) => inputValues[`${contractMethod.name}/${'name' in input && input.name || i}`]) ?? []


	// Formatting
	import { formatIdentifierToWords } from '../utils/formatIdentifierToWords'


	import Address from './Address.svelte'
	import AddressInput from './AddressInput.svelte'
	import AddressWithLabel from './AddressWithLabel.svelte'
	import ConnectedAccountSelect from './ConnectedAccountSelect.svelte'
	import BigNumberInput from './BigNumberInput.svelte'
	import HeightContainer from './HeightContainer.svelte'
	import NetworkIcon from './NetworkIcon.svelte'
	import TokenBalance from './TokenBalance.svelte'
	import TransactionFlow from './TransactionFlow.svelte'
	import { TenderlyIcon } from '../assets/icons'


	// Transitions
	import { flip } from 'svelte/animate'
	import { scale } from 'svelte/transition'
</script>


<style>
	form {
		/* justify-self: center; */
	}

	form input {
		flex: 1;
	}

	.input-param {
		display: grid;
		grid-template-columns: 1fr minmax(52ch, 1fr) 1fr;
		align-items: center;
	}
	.input-param > :first-child {
		text-align: right;
	}

	.input-index {
		opacity: 0.8;
	}

	.tenderly {
		--primary-color: #6e5e9b;
	}
</style>


<section class="column">
	<header class="bar wrap">
		<h3>Smart Contract Interactions</h3>

		<label>
			<span>{selectedMethod && methodsByGroup.find(group => group.methods.includes(selectedMethod))?.singularName || 'Method'}</span> 

			<select bind:value={selectedMethod}>
				{#each methodsByGroup.filter(({ methods }) => methods.length) as { name, methods }}
					<optgroup label={name}>
						{#each methods.sort((a, b) => a.name.localeCompare(b.name)) as method}
							<option value={method}>{formatIdentifierToWords(method.name, true)}</option>
						{/each}
					</optgroup>
				{:else}
					<option value={undefined} selected disabled>[No interactions available.]</option>
				{/each}
			</select>
		</label>
	</header>

	{#if selectedMethod}
		<TransactionFlow
			accountConnection={selectedAccountConnection}
			{network}
			{networkProvider}

			{publicClient}

			{contractAddress}
			{contractAbi}
			contractMethodName={contractMethod.name}
			{contractMethodArgs}
			{payableAmount}

			onTransactionSuccess={async tx => {
				console.log(tx)
			}}
		>
			<svelte:fragment slot="idle" let:actions={{ next }} let:isValid>
				<header class="bar">
					<h4 class="row-inline">
						<!-- <span class="row-inline"> -->
							<NetworkIcon {network} />
							<!-- {network.name}
						</span> -->
						›
						<AddressWithLabel
							{network}
							label={contractName}
							address={contractAddress}
							format="middle-truncated"
							linked
						/>
						›
						<abbr title={contractMethod.name}>{formatIdentifierToWords(contractMethod.name, true)}</abbr>
					</h4>

					{#if contractMethod.stateMutability === 'nonpayable' || contractMethod.stateMutability === 'payable'}
						<label>
							<span>From</span>
							<ConnectedAccountSelect bind:selectedAccountConnection required />
						</label>
					{/if}
				</header>

				{#if contractMethod.inputs.length}
					<hr>

					<HeightContainer>
						{#each contractMethod.inputs as input, i (`${contractMethod.name || i}/${input.name || i}`)}
							{@const inputKey = `${contractMethod.name || i}/${input.name || i}`}

							<!-- svelte-ignore a11y-label-has-associated-control -->
							<label class="input-param" transition:scale|global={{ duration: 300, start: 0.8, delay: i * 10 }} animate:flip>
								<span>
									{#if input.name}
										<abbr title={input.name}>{formatIdentifierToWords(input.name, true)}</abbr>
									{:else}
										<span class="input-index">Input {i + 1}</span>
									{/if}
								</span>
								
								{#if input.type === 'address'}
									<AddressInput
										bind:address={inputValues[inputKey]}
										required
									/>
								{:else if input.type.startsWith('int')}
									{@const numBits = BigInt(input.type.match(/\d+/)?.[0])}

									<BigNumberInput
										required
										bind:value={inputValues[inputKey]}
										min={2n ** (numBits - 1n) * -1n}
										max={2n ** (numBits - 1n) - 1n}
									/>
								{:else if input.type.startsWith('uint')}
									{@const numBits = BigInt(input.type.match(/\d+/)?.[0])}

									<BigNumberInput
										required
										bind:value={inputValues[inputKey]}
										min={0n}
										max={2n ** numBits - 1n}
									/>
								{:else}
									<input
										type="text"
										required
										bind:value={inputValues[inputKey]}
									/>
								{/if}

								<abbr class="card-annotation" title="{input.type} ({input.indexed ? `indexed ` : ''}{input.internalType})">{input.type}</abbr>
							</label>
						{/each}
					</HeightContainer>
				{/if}

				<hr>

				<footer class="bar">
					<label>
						<!-- <span>Estimated Gas:</span>
						<output>

							gwei
						</output> -->

						{#if contractMethod.stateMutability === 'payable'}
							<label>
								<span>Pay {network.nativeCurrency.symbol}</span>
								<TokenAmountSelect
									bind:token={network.nativeCurrency.symbol}
									bind:amount={payableAmount}
								/>
							</label>
						{/if}
					</label>

					<button type="submit" class="medium">Next ›</button>
				</footer>
			</svelte:fragment>

			<svelte:fragment slot="confirming" let:walletName let:walletIcon let:actions>
				<article class="card">
					<header class="row spaced">
						<span class="row">
							<img src={walletIcon} width="25" />
							<Address {network} address={selectedAccountConnection?.state?.account?.address} format="middle-truncated" />
						</span>

						<span>
							will
							{#if payableAmount > 0}
								send
								<TokenBalance
									{network} erc20Token={network.nativeCurrency}
									balance={payableAmount}
								/>
								to
							{:else}
								call
							{/if}
						</span>

						<span>
							<AddressWithLabel
								{network}
								label={contractName}
								address={contractAddress}
								format="middle-truncated"
								linked
							/>
							›
							<abbr title={contractMethod.name}>{formatIdentifierToWords(contractMethod.name, true)}</abbr>
						</span>

						{#if contractMethod.inputs.length}
							with {contractMethod.inputs.length} parameters:
						{/if}
					</header>

					{#if contractMethod.inputs.length}
						<hr>

						{#each contractMethod.inputs as input, i (`${contractMethod.name || i}/${input.name || i}`)}
							{@const inputKey = `${contractMethod.name || i}/${input.name || i}`}
							{@const arg = inputValues[inputKey]}

							<label class="input-param" transition:scale|global={{ duration: 300, start: 0.8, delay: i * 25 }}>
								<span>
									{#if input.name}
										<abbr title={input.name}>{formatIdentifierToWords(input.name, true)}</abbr>
									{:else}
										<span class="input-index">Input {i + 1}</span>
									{/if}
								</span>

								<output>{#if input.type === 'address'}<Address {network} address={arg} />{:else}{arg}{/if}</output>

								<abbr class="card-annotation" title="{input.type} ({input.indexed ? `indexed ` : ''}{input.internalType})">{input.type}</abbr>
							</label>
						{/each}
					{/if}
				</article>

				<div class="row spaced">
					<button type="button" class="medium cancel" on:click={actions.back}>‹ Back</button>

					<div class="row">
						{#if isReadable(contractMethod)}
							<button type="button" class="medium" on:click={actions.query}><img src={networkProviderConfigByProvider[$preferences.rpcNetwork]?.icon} width="16" /> Query Contract ›</button>
						{:else if isWritable(contractMethod)}
							<button type="button" class="tenderly medium" on:click={actions.simulate}><img src={TenderlyIcon} width="16" /> Simulate Transaction ›</button>

							<button type="button" class="medium" on:click={actions.sign}><img src={walletIcon} width="16" /> Sign & Broadcast Transaction ›</button>
						{:else}
						{/if}
					</div>
				</div>
			</svelte:fragment>

			<svelte:fragment slot="query-result" let:result>
				<hr>

				{@const isSingleOutput = contractMethod.outputs?.length === 1}

				{#each contractMethod.outputs as output, i (`${contractMethod.name || i}/${output.name || i}`)}
					<!-- {@const outputKey = `${method.name || i}/${output.name || i}`} -->
					{@const outputValue = isSingleOutput ? result : result[i]}

					<label class="input-param" transition:scale|global={{ duration: 300, start: 0.8, delay: i * 25 }}>
						<span>
							{#if output.name}
								<abbr title={output.name}>{formatIdentifierToWords(output.name, true)}</abbr>
							{:else if isSingleOutput && contractMethod.name}
								<abbr title={contractMethod.name}>{formatIdentifierToWords(contractMethod.name, true)}</abbr>
							{:else}
								<span class="input-index">Output {i + 1}</span>
							{/if}
						</span>

						<output>{#if output.type === 'address'}<Address {network} address={outputValue} />{:else}{outputValue}{/if}</output>

						<abbr class="card-annotation" title="{output.type} ({output.indexed ? `indexed ` : ''}{output.internalType})">{output.type}</abbr>
					</label>
				{/each}
			</svelte:fragment>

			<svelte:fragment slot="simulating-actions" let:actions>
				<div class="row spaced">
					<button type="button" class="medium cancel" on:click={actions.confirm}>‹ Back</button>

					<div class="row">
						<button type="button" class="medium destructive" on:click={actions.cancel}>« Start Over</button>
						<button type="button" class="tenderly medium" on:click={actions.simulate}><img src={TenderlyIcon} width="16" /> Simulate Again</button>
					</div>
				</div>
			</svelte:fragment>

			<!-- <svelte:fragment slot="pending"> -->
			<svelte:fragment slot="pending-message" let:network>
				Pending...
			</svelte:fragment>

			<!-- <svelte:fragment slot="failed"> -->

			<!-- <svelte:fragment slot="success"> -->
			<svelte:fragment slot="success-message" let:network>
				Success!
			</svelte:fragment>
		</TransactionFlow>
	{/if}
</section>
