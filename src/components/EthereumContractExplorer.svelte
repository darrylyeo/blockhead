<script lang="ts">
	// Types/constants
	import type { Ethereum } from '../data/networks/types'
	import type { NetworkProvider } from '../data/networkProviders/types'
	import { getViemPublicClient } from '../data/networkProviders'

	enum ContractCodeType {
		// CreationBytecode = 'Creation Bytecode',
		RuntimeBytecode = 'Runtime Bytecode',
	}


	// Context
	import { preferences } from '../state/preferences'


	// Inputs
	export let name: string
	export let network: Ethereum.Network
	export let contractAddress: Ethereum.ContractAddress
	export let networkProvider: NetworkProvider

	export let transactionProvider

	// (Computed)
	$: networkProvider = $$props.networkProvider ?? $preferences.rpcNetwork

	let publicClient: Ethereum.PublicClient | undefined
	$: publicClient = network && networkProvider && getViemPublicClient({
		network,
		networkProvider: networkProvider,
	})

	$: transactionProvider = $$props.transactionProvider || $preferences.transactionProvider


	// Outputs
	export let contractBytecode: Ethereum.ContractBytecode
	export let contractMetadata: Ethereum.ContractMetadata<string>
	export let contractName: string | undefined
	// (Computed)
	$: contractName = contractMetadata && Object.values(contractMetadata.settings.compilationTarget)?.[0]


	// Internal state
	let showContractCodeTypeOrSourcePath: ContractCodeType | keyof typeof contractMetadata.sources = ContractCodeType.RuntimeBytecode

	// (Computed)
	$: source = contractMetadata?.sources?.[showContractCodeTypeOrSourcePath]

	// Auto-set to target source path
	let hasLoadedMetadata = {} as Record<Ethereum.Address, boolean>
	$: if(contractAddress && contractMetadata){
		const sourcePaths = Object.keys(contractMetadata.sources)

		const targetSourcePath =
			sourcePaths.length === 1
				? sourcePaths[0]
				: sourcePaths.find(sourcePath => sourcePath.match(new RegExp(`(?:^|[/])${contractName}[.]`)))

		if(!hasLoadedMetadata[contractAddress])
			showContractCodeTypeOrSourcePath = targetSourcePath ?? ContractCodeType.RuntimeBytecode
		
		hasLoadedMetadata[contractAddress] = true
	}else{
		showContractCodeTypeOrSourcePath = ContractCodeType.RuntimeBytecode
	}


	// Components
	import Address from './Address.svelte'
	import EthereumContractBytecodeLoader from './EthereumContractBytecodeLoader.svelte'
	import EthereumContractMetadataLoader from './EthereumContractMetadataLoader.svelte'
	import EthereumTransactionForm from './EthereumTransactionForm.svelte'
	import EvmBytecode from './EvmBytecode.svelte'
	import IpfsLoader from './IpfsLoader.svelte'


	import { fade, fly } from 'svelte/transition'
</script>


<style>
	.bar {
		--padding-inner: 1em;
	}
	label {
		font-size: 0.9em;
	}

	h3 {
		line-height: 1.6;
	}

	.source-code {
		display: block;
	}
</style>


<EthereumContractBytecodeLoader
	{contractAddress}
	{networkProvider}
	{network}
	showIf={contractBytecode => !!contractBytecode}
	bind:contractBytecode
	let:contractBytecode
>
	<slot slot="header" name="header" />

	<section>
		<EthereumContractMetadataLoader
			{contractAddress}
			{network}
			bind:contractMetadata
			let:contractMetadata
			let:swarmUri
			let:sourcifyUrl
			let:contractSourceProvider
		>
			<header class="bar" slot="header" let:contractMetadata>
				<slot name="title" contractName={name} {network} {contractAddress}>
					<h4><Address {network} address={contractAddress} format="middle-truncated" let:formattedAddress>{name || formattedAddress}</Address></h4>
				</slot>

				<label>
					<span>View: </span>
					<select bind:value={showContractCodeTypeOrSourcePath}>
						<optgroup label="On-Chain">
							{#each Object.values(ContractCodeType) as contractCodeType}
								<option value={contractCodeType} selected={showContractCodeTypeOrSourcePath === contractCodeType}>{contractCodeType}</option>
							{/each}
						</optgroup>

						{#if contractMetadata}
							<optgroup label="Source Code">
								<!-- Uncaught ReferenceError: contractMetadata is not defined -->
								{#each Object.entries(contractMetadata?.sources) as [sourcePath, source]}
									<option value={sourcePath} selected={showContractCodeTypeOrSourcePath === sourcePath}>{sourcePath}</option>
								{/each}
							</optgroup>
						{/if}
					</select>
				</label>
			</header>

			<div class="stack">
				{#key showContractCodeTypeOrSourcePath}
					{#if source && !Object.values(ContractCodeType).includes(showContractCodeTypeOrSourcePath)}
						{@const sourceFile = showContractCodeTypeOrSourcePath.match(/[^/]+$/)?.[0]}
						{@const sourceFileName = sourceFile?.replace(/.sol$/, '')}
						{@const solidityDefinitionType =
							contractMetadata?.language === 'Solidity' &&
							source.content?.match(new RegExp(`((?:abstract )?library|contract|interface|function|constant|struct|enum|type|error)\\s+(${sourceFileName})`))?.[1]
						}

						<section class="card" in:fly|global={{ x: 10, duration: 200 }} out:fly|global={{ x: -10, duration: 200 }}>
							<header class="bar">
								<abbr
									class="row-inline"
									title={[
										showContractCodeTypeOrSourcePath,
										source.license && `License: ${source.license}`,
										source.keccak256 && `keccak256 hash: ${source.keccak256}`
									].filter(Boolean).join('\n\n')}
								>
									<h4>{sourceFile}</h4>
									{#if source.license}<small><span class="card-annotation">{source.license}</span></small>{/if}
								</abbr>

								<abbr class="card-annotation" title="{contractMetadata?.language} {contractMetadata?.compiler?.version}">
									{contractMetadata?.language}
									<!-- {contractMetadata?.compiler?.version} -->
									{#if solidityDefinitionType}{solidityDefinitionType}{/if}
								</abbr>
							</header>

							<hr>

							{#if source.content}
								<code class="scrollable-list" style="--resizeVertical-defaultHeight: 30em;">{source.content}</code>

								<hr>

								<footer class="footer bar">
									<a href={sourcifyUrl || swarmUri} target="_blank">{contractSourceProvider}</a>

									<!-- {#if source.license}<span>License: {source.license}</span>{/if} -->
								</footer>
							{:else if source.urls?.length}
								{@const ipfsContentId = source.urls.find(url => url.startsWith('dweb:/'))?.match(/^dweb:\/ipfs\/(.+)$/)?.[1]}
								<!-- {@const ipfsUrl = source.urls.find(url => url.startsWith('dweb:/'))} -->

								<IpfsLoader
									{ipfsContentId}
									errorMessage="Couldn't fetch content on Sourcify."
									let:text={sourceCode}
									let:ipfsContentId
									let:resolvedIpfsUrl
									let:ipfsGatewayProvider
								>
									<code class="source-code scrollable-list" style="--resizeVertical-defaultHeight: 30em;">{sourceCode}</code>

									<hr>

									<footer class="footer row spaced">
										<span>
											<a href={sourcifyUrl} target="_blank">Sourcify</a>
										</span>

										<!-- {#if source.license}<span>License: {source.license}</span>{/if} -->
										
										<span><a href="https://{ipfsGatewayProvider.gatewayDomain}" title="IPFS Gateway: {ipfsGatewayProvider.name} ({ipfsGatewayProvider.gatewayDomain})" target="_blank">IPFS</a> â€º <a href={resolvedIpfsUrl} target="_blank">{ipfsContentId}</a></span>
									</footer>
								</IpfsLoader>
							{/if}
						</section>
					{:else}
						<section class="card" in:fly|global={{ x: 10, duration: 200 }} out:fly|global={{ x: -10, duration: 200 }}>
							<EvmBytecode
								{contractBytecode}
								{networkProvider}
							>
								<h4 slot="title">{showContractCodeTypeOrSourcePath}</h4>
							</EvmBytecode>
						</section>
					{/if}
				{/key}
			</div>

			{#if contractMetadata}
				<hr>

				<EthereumTransactionForm
					{network}
					{networkProvider}
					{publicClient}
					{contractName}
					{contractAddress}
					contractAbi={contractMetadata.output.abi}
				/>
			{/if}
		</EthereumContractMetadataLoader>
	</section>
</EthereumContractBytecodeLoader>
