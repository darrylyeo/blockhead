/**
 * Farcaster API V2
 * 2.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
import * as QS from "@oazapfts/runtime/query";
export const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders> = {
    headers: {},
    baseUrl: "https://api.neynar.com/v2",
};
const oazapfts = Oazapfts.runtime(defaults);
export const servers = {
    server1: "https://api.neynar.com/v2"
};
export type UserFidResponse = {
    fid: number;
};
export type ErrorRes = {
    code?: string;
    message: string;
    property?: string;
    status?: number;
};
export type Ed25519PublicKey = string;
export type Fid = number;
export type DeveloperManagedSigner = {
    public_key: Ed25519PublicKey;
    status: Status;
    signer_approval_url?: string;
    fid?: Fid;
};
export type RegisterDeveloperManagedSignedKeyReqBody = {
    public_key: Ed25519PublicKey;
    /** Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key */
    signature: string;
    /** Application FID */
    app_fid: Fid;
    /** unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended) */
    deadline: number;
};
export type SignerUuid = string;
export type Signer = {
    signer_uuid: SignerUuid;
    public_key: Ed25519PublicKey;
    status: Status2;
    signer_approval_url?: string;
    fid?: Fid;
};
export type RegisterSignerKeyReqBody = {
    signer_uuid: SignerUuid;
    /** Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key */
    signature: string;
    /** Application FID */
    app_fid: Fid;
    /** unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended) */
    deadline: number;
};
export type Address = string;
export type SolAddress = string;
export type User = {
    "object": Object_;
    fid: Fid;
    username: string;
    display_name?: string;
    custody_address: Address;
    /** The URL of the user's profile picture */
    pfp_url?: string;
    profile: {
        bio: {
            text: string;
            mentioned_profiles: string[];
        };
    };
    /** The number of followers the user has. */
    follower_count: number;
    /** The number of users the user is following. */
    following_count: number;
    verifications: Address[];
    verified_addresses: {
        eth_addresses: Address[];
        sol_addresses: SolAddress[];
    };
    active_status: ActiveStatus;
    power_badge: boolean;
    /** Adds context on the viewer's follow relationship with the user. */
    viewer_context?: {
        /** Indicates if the viewer is following the user. */
        following: boolean;
        /** Indicates if the viewer is followed by the user. */
        followed_by: boolean;
    };
};
export type ProfileUrl = {
    pfp: {
        url: string;
    };
};
export type SearchedUser = User & ProfileUrl;
export type NextCursor = {
    cursor: string | null;
};
export type UserSearchResponse = {
    result: {
        users: SearchedUser[];
        next?: NextCursor;
    };
};
export type BulkUsersResponse = {
    users: User[];
};
export type UsersResponse = {
    users: User[];
    next: NextCursor;
};
export type BulkUsersByAddressResponse = {
    [key: string]: User[];
};
export type ChannelViewerContext = {
    /** Indicates if the viewer is following the channel. */
    following: boolean;
};
export type Channel = {
    id: string;
    url: string;
    name?: string;
    description?: string;
    "object": Object2;
    /** Epoch timestamp in seconds. */
    created_at?: number;
    /** Number of followers the channel has. */
    follower_count?: number;
    image_url?: string;
    parent_url?: string;
    lead?: User;
    hosts?: User[];
    viewer_context?: ChannelViewerContext;
};
export type ChannelListResponse = {
    channels: Channel[];
    next?: NextCursor;
};
export type UpdateUserReqBody = {
    signer_uuid: SignerUuid;
    bio?: string;
    pfp_url?: string;
    url?: string;
    username?: string;
    display_name?: string;
};
export type OperationResponse = {
    success: boolean;
    message?: string;
};
export type RegisterUserReqBody = {
    signature: string;
    fid: number;
    requested_user_custody_address: string;
    deadline: number;
    fname?: string;
};
export type RegisterUserResponse = {
    success: true;
    message: string;
    signer: Signer;
};
export type PublishMessageReqBody = object;
export type PublishMessageResponse = object;
export type Timestamp = string;
export type EmbedUrl = {
    url: string;
};
export type CastId = {
    fid: Fid;
    hash: string;
};
export type EmbedCastId = {
    cast_id: CastId;
};
export type EmbeddedCast = EmbedUrl | EmbedCastId;
export type Cast = {
    hash: string;
    parent_hash: string | null;
    parent_url: string | null;
    root_parent_url: string | null;
    parent_author: Fid & {
        fid: number | null;
    };
    author: User;
    text: string;
    timestamp: Timestamp;
    embeds: EmbeddedCast[];
    "type"?: CastNotificationType;
};
export type FrameActionButton = {
    /** Title of the button */
    title?: string;
    /** Index of the button */
    index: number;
    action_type: FrameButtonActionType;
    /** Target of the button */
    target?: string;
    /** Used specifically for the tx action type to post a successful transaction hash */
    post_url?: string;
};
export type Frame = {
    /** Version of the frame */
    version: string;
    /** URL of the image */
    image: string;
    buttons?: FrameActionButton[];
    /** Post URL to take an action on this frame */
    post_url?: string;
    /** URL of the frames */
    frames_url: string;
    title?: string;
    image_aspect_ratio?: string;
    input?: {
        /** Input text for the frame */
        text?: string;
    };
    state?: {
        /** State for the frame in a serialized format */
        serialized?: string;
    };
};
export type ReactionLike = {
    fid: Fid;
};
export type ReactionRecast = {
    fid: Fid;
    fname: string;
};
export type CastWithInteractionsReactions = {
    likes: ReactionLike[];
    recasts: ReactionRecast[];
    likes_count: number;
    recasts_count: number;
};
export type CastWithInteractionsReplies = {
    count: number;
};
export type CastWithInteractions = Cast & {
    frames?: Frame[];
    reactions: CastWithInteractionsReactions;
    replies: CastWithInteractionsReplies;
    thread_hash: string | null;
    mentioned_profiles: User[];
    channel?: Channel;
};
export type CastResponse = {
    cast: CastWithInteractions;
};
export type CastParent = string;
export type PostCastReqBody = {
    signer_uuid: SignerUuid;
    text?: string;
    embeds?: EmbeddedCast[];
    parent?: CastParent;
    /** Channel ID of the channel where the cast is to be posted. e.g. neynar, farcaster, warpcast */
    channel_id?: string;
    /** An Idempotency key to prevent duplicate publishing of events. Recommended format is a 16-character string generated by the developer at the time of publishing. Use the same idem key on retry attempts. */
    idem?: string;
    parent_author_fid?: Fid;
};
export type PostCastResponse = {
    success: boolean;
    cast: {
        hash: Address;
        author: {
            fid: Fid;
        };
        text: string;
    };
};
export type DeleteCastReqBody = {
    signer_uuid: SignerUuid;
    target_hash: Address;
};
export type CastsResponse = {
    result: {
        casts: CastWithInteractions[];
    };
};
export type ReplyDepth = number;
export type CastWithInteractionsAndConversations = CastWithInteractions & {
    /** note: This is recursive. It contains the direct replies to the cast and their direct replies up to n reply_depth. */
    direct_replies?: CastWithInteractionsAndConversations[];
};
export type Conversation = {
    conversation: {
        cast: CastWithInteractionsAndConversations;
        chronological_parent_casts?: CastWithInteractions[];
    };
};
export type FeedResponse = {
    casts: CastWithInteractions[];
    next: NextCursor;
};
export type BulkCastsResponse = {
    casts: CastWithInteractions[];
};
export type NeynarPageImage = {
    /** The URL of the page's image. */
    url: string;
    /** The aspect ratio of the image. */
    aspect_ratio: Aspect_ratio;
};
export type NeynarNextFramePage = {
    /** The UUID of the next page. */
    uuid: string;
};
export type NeynarNextFramePageRedirect = {
    /** The URL to redirect to. */
    redirect_url: string;
};
export type NeynarNextFramePageMintUrl = {
    /** The URL for minting, specific to the mint action. */
    mint_url: string;
};
export type NeynarPageButton = {
    /** The title of the button. */
    title: string;
    /** The index of the button, first button should have index 1 and so on. */
    index: number;
    /** The type of action that the button performs. */
    action_type: Action_type;
    next_page?: NeynarNextFramePage | NeynarNextFramePageRedirect | NeynarNextFramePageMintUrl;
};
export type NeynarPageInput = {
    text?: {
        /** Indicates if text input is enabled. */
        enabled: boolean;
        /** The placeholder text for the input. */
        placeholder?: string;
    };
};
export type NeynarFramePage = {
    /** Unique identifier for the page. */
    uuid: string;
    /** The version of the page schema. */
    version: string;
    /** The title of the page. */
    title: string;
    image: NeynarPageImage;
    buttons?: NeynarPageButton[];
    input?: NeynarPageInput;
};
export type NeynarFrame = {
    /** Unique identifier for the frame. */
    uuid: string;
    /** Name of the frame. */
    name: string;
    /** Generated link for the frame's first page. */
    link: string;
    pages: NeynarFramePage[];
    /** Indicates if the frame is valid. */
    valid?: boolean;
};
export type NeynarFrameCreationRequest = {
    /** The name of the frame. */
    name: string;
    pages: NeynarFramePage[];
};
export type NeynarFrameUpdateRequest = {
    /** The UUID of the frame to update. */
    uuid: string;
    /** The name of the frame. */
    name?: string;
    pages: NeynarFramePage[];
};
export type DeleteFrameResponse = {
    success?: boolean;
    uuid?: string;
};
export type ReactionReqBody = {
    signer_uuid: SignerUuid;
    reaction_type: ReactionType;
    target: string;
    /** An Idempotency key to prevent duplicate publishing of events. Recommended format is a 16-character string generated by the developer at the time of publishing. Use the same idem key on retry attempts. */
    idem?: string;
};
export type AddVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
    block_hash: string;
    eth_signature: string;
};
export type RemoveVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
};
export type FollowReqBody = {
    signer_uuid: SignerUuid;
    target_fids: Fid[];
};
export type FollowResponse = {
    success: boolean;
    target_fid: Fid;
};
export type BulkFollowResponse = {
    success: boolean;
    details: FollowResponse[];
};
export type UserResponse = {
    user: User;
};
export type AuthorizationUrlResponse = {
    authorization_url: string;
};
export type CastHash = string;
export type FrameInput = {
    /** Input text for the frame */
    text?: string;
};
export type FrameState = {
    /** State for the frame in a serialized format */
    serialized: string;
};
export type FrameTransaction = {
    /** Transaction hash */
    hash: string;
};
export type FrameAddress = string;
export type FrameAction = {
    version?: string;
    title?: string;
    image?: string;
    button: FrameActionButton;
    input?: FrameInput;
    state?: FrameState;
    transaction?: FrameTransaction;
    address?: FrameAddress;
    /** URL of the frames */
    frames_url: string;
    /** URL of the post to get the next frame */
    post_url: string;
};
export type FrameActionReqBody = {
    signer_uuid: SignerUuid;
    cast_hash: CastHash;
    action: FrameAction;
};
export type ValidatedFrameAction = {
    "object": Object3;
    url: string;
    interactor: User;
    tapped_button: {
        index: number;
    };
    input?: FrameInput;
    state: FrameState;
    cast: CastWithInteractions;
    timestamp: Timestamp;
    signer?: {
        client?: User;
    };
    transaction?: FrameTransaction;
    address?: FrameAddress;
};
export type ValidateFrameActionResponse = {
    valid: boolean;
    action: ValidatedFrameAction;
};
export type FrameValidateListResponse = {
    frames: string[];
};
export type FrameValidateAnalyticsInteractors = {
    interactors: {
        fid: Fid;
        username: string;
        interaction_count: number;
    }[];
};
export type FrameValidateAnalyticsTotalInteractors = {
    total_interactors: number;
};
export type FrameValidateAnalyticsInteractionsPerCast = {
    interactions_per_cast: {
        start: string;
        stop: string;
        time: string;
        interaction_count: number;
        cast_url: string;
    }[];
};
export type FrameValidateAnalyticsInputText = {
    input_texts: {
        fid: Fid;
        username: string;
        input_text: string;
    }[];
};
export type FrameValidateAnalyticsResponse = FrameValidateAnalyticsInteractors | FrameValidateAnalyticsTotalInteractors | FrameValidateAnalyticsInteractionsPerCast | FrameValidateAnalyticsInputText;
export type Follow = {
    "object": Object4;
    user: User;
};
export type CastDehydrated = {
    hash: string;
    "object": Object6;
};
export type ReactionWithUserInfo = {
    "object": Object5;
    cast: CastDehydrated;
    user: User;
};
export type Notification = {
    "object": string;
    most_recent_timestamp: string;
    "type": Type;
    follows?: Follow[];
    cast?: CastWithInteractions;
    reactions?: ReactionWithUserInfo[];
};
export type NotificationsResponse = {
    notifications: Notification[];
    next: NextCursor;
};
export type ChannelSearchResponse = {
    channels: Channel[];
};
export type ChannelResponse = {
    channel: Channel;
};
export type UsersActiveChannelsResponse = {
    channels?: Channel[];
    next?: NextCursor;
};
export type ChannelActivity = {
    "object": Object7;
    cast_count_1d: string;
    cast_count_7d: string;
    cast_count_30d: string;
    channel: Channel;
};
export type TrendingChannelResponse = {
    channels: ChannelActivity[];
    next: NextCursor;
};
export type HydratedFollower = {
    "object"?: Object8;
    user?: User;
};
export type UserDehydrated = {
    "object": Object9;
    fid: Fid;
};
export type DehydratedFollower = {
    "object"?: Object8;
    user?: UserDehydrated;
};
export type RelevantFollowersResponse = {
    top_relevant_followers_hydrated: HydratedFollower[];
    all_relevant_followers_dehydrated: DehydratedFollower[];
};
export type ReactionWithCastInfo = {
    reaction_type: Reaction_type;
    cast: CastWithInteractions;
    reaction_timestamp: string;
    "object": Object10;
    user: UserDehydrated;
};
export type ReactionsResponse = {
    reactions: ReactionWithCastInfo[];
    next: NextCursor;
};
export type ReactionForCast = {
    reaction_type: Reaction_type;
    reaction_timestamp: string;
    "object": Object10;
    user: User;
};
export type ReactionsCastResponse = {
    reactions: ReactionForCast[];
    next: NextCursor;
};
export type FnameAvailabilityResponse = {
    available: boolean;
};
export type StorageAllocation = {
    "object"?: string;
    user?: UserDehydrated;
    units?: number;
    expiry?: string;
    timestamp?: string;
};
export type StorageAllocationsResponse = {
    total_active_units?: number;
    allocations?: StorageAllocation[];
};
export type StorageObject = {
    "object"?: string;
    used?: number;
    capacity?: number;
};
export type StorageUsageResponse = {
    "object"?: string;
    user?: UserDehydrated;
    casts?: StorageObject;
    reactions?: StorageObject;
    links?: StorageObject;
    verified_addresses?: StorageObject;
    username_proofs?: StorageObject;
    signers?: StorageObject;
    total_active_units?: number;
};
export type WebhookSecret = {
    uid: string;
    value: string;
    expires_at: string;
    created_at: string;
    updated_at: string;
    deleted_at: string;
};
export type WebhookSubscriptionFiltersFollow = {
    fids?: number[];
    target_fids?: number[];
};
export type WebhookSubscriptionFiltersReaction = {
    fids?: number[];
    target_fids?: number[];
};
export type WebhookSubscriptionFilters = {
    "cast.created"?: {
        author_fids?: number[];
        mentioned_fids?: number[];
        parent_urls?: string[];
        root_parent_urls?: string[];
        /** Regex pattern to match the text key of the cast.
        **Note:**
        1) Regex must be parsed by Go's RE2 engine (Test your expression here: https://www.lddgo.net/en/string/golangregex)
        2) Use backslashes to escape special characters.
        For example: (?i)\\$degen should be written as (?i)\\\\$degen
         */
        text?: string;
        /** Regex pattern to match the embeded_url (key embeds) of the cast.
        **Note:**
        1) Regex must be parsed by Go's RE2 engine (Test your expression here: https://www.lddgo.net/en/string/golangregex)
        2) Use backslashes to escape special characters.
        For example: \\b(farcaster|neynar)\\b should be written as \\\\b(farcaster|neynar)\\\\b
         */
        embeds?: string;
    };
    "user.created"?: object;
    "user.updated"?: {
        fids?: number[];
    };
    "follow.created"?: WebhookSubscriptionFiltersFollow;
    "follow.deleted"?: WebhookSubscriptionFiltersFollow;
    "reaction.created"?: WebhookSubscriptionFiltersReaction;
    "reaction.deleted"?: WebhookSubscriptionFiltersReaction;
};
export type WebhookSubscription = {
    "object": Object12;
    subscription_id: string;
    filters: WebhookSubscriptionFilters;
    created_at: string;
    updated_at: string;
};
export type Webhook = {
    "object": Object11;
    webhook_id: string;
    developer_uuid: string;
    target_url: string;
    title: string;
    secrets: WebhookSecret[];
    description: string;
    http_timeout: string;
    rate_limit: number;
    active: boolean;
    rate_limit_duration: string;
    created_at: string;
    updated_at: string;
    deleted_at: string;
    subscription?: WebhookSubscription;
};
export type WebhookResponse = {
    message?: string;
    success?: boolean;
    webhook?: Webhook;
};
export type WebhookPostReqBody = {
    name: string;
    url: string;
    subscription?: WebhookSubscriptionFilters;
};
export type WebhookPatchReqBody = {
    webhook_id: string;
    active: Active;
};
export type WebhookPutReqBody = WebhookPostReqBody & {
    webhook_id: string;
};
export type WebhookDeleteReqBody = {
    webhook_id: string;
};
export type WebhookListResponse = {
    webhooks: Webhook[];
};
export type MuteList = {
    "object": Object13;
    muted: User;
    muted_at: Timestamp;
};
export type MuteListResponse = {
    mutes: MuteList[];
    next: NextCursor;
};
export type MuteReqBody = {
    fid: Fid;
    muted_fid: Fid;
};
export type MuteResponse = {
    success: boolean;
    message?: string;
};
/**
 * Fetches fid to assign it new user
 */
export function getFarcasterUserFid(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserFidResponse;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/fid", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches the status of a signer by public key
 */
export function getFarcasterSignerDeveloperManaged(apiKey: string, publicKey: Ed25519PublicKey, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeveloperManagedSigner;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/signer/developer_managed${QS.query(QS.explode({
        public_key: publicKey
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Registers Signed Key
 */
export function postFarcasterSignerDeveloperManagedSignedKey(apiKey: string, registerDeveloperManagedSignedKeyReqBody: RegisterDeveloperManagedSignedKeyReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeveloperManagedSigner;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer/developer_managed/signed_key", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerDeveloperManagedSignedKeyReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetches the status of a signer
 */
export function signer(apiKey: string, signerUuid: SignerUuid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/signer${QS.query(QS.explode({
        signer_uuid: signerUuid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Creates a signer and returns the signer status
 */
export function postFarcasterSigner(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer", {
        ...opts,
        method: "POST",
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Register Signed Key
 */
export function postFarcasterSignerSignedKey(apiKey: string, registerSignerKeyReqBody: RegisterSignerKeyReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer/signed_key", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerSignerKeyReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Search for Usernames
 */
export function getFarcasterUserSearch(apiKey: string, q: string, { viewerFid, limit, cursor }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserSearchResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/search${QS.query(QS.explode({
        q,
        viewer_fid: viewerFid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch users based on FIDs
 */
export function getFarcasterUserBulk(apiKey: string, fids: string, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/bulk${QS.query(QS.explode({
        fids,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch power users
 */
export function getFarcasterUserPower(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/power${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch active users
 */
export function getFarcasterUserActive(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/active${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches users based on Eth or Sol addresses
 */
export function getFarcasterUserBulkByAddress(apiKey: string, addresses: string, { addressTypes }: {
    addressTypes?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersByAddressResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/bulk-by-address${QS.query(QS.explode({
        addresses,
        address_types: addressTypes
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve all channels that a given fid follows
 */
export function getFarcasterUserChannels(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/user/channels${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Update user profile
 */
export function patchFarcasterUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user", oazapfts.json({
        ...opts,
        method: "PATCH",
        body: updateUserReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Register account on farcaster
 */
export function postFarcasterUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: RegisterUserResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 409;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerUserReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Publish a message to farcaster
 */
export function postFarcasterMessage(apiKey: string, publishMessageReqBody: PublishMessageReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PublishMessageResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/message", oazapfts.json({
        ...opts,
        method: "POST",
        body: publishMessageReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve cast for a given hash or Warpcast URL
 */
export function cast(apiKey: string, identifier: string, $type: CastParamType, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast${QS.query(QS.explode({
        identifier,
        "type": $type
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a cast
 */
export function postFarcasterCast(apiKey: string, postCastReqBody: PostCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PostCastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "POST",
        body: postCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a cast
 */
export function deleteFarcasterCast(apiKey: string, deleteCastReqBody: DeleteCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: deleteCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Gets information about an array of casts
 */
export function casts(apiKey: string, casts: string, { viewerFid, sortType }: {
    viewerFid?: Fid;
    sortType?: "trending" | "likes" | "recasts" | "replies" | "recent";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/casts${QS.query(QS.explode({
        casts,
        viewer_fid: viewerFid,
        sort_type: sortType
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve the conversation for a given cast
 */
export function getFarcasterCastConversation(apiKey: string, identifier: string, $type: CastParamType, { replyDepth, includeChronologicalParentCasts }: {
    replyDepth?: ReplyDepth;
    includeChronologicalParentCasts?: boolean;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Conversation;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast/conversation${QS.query(QS.explode({
        identifier,
        "type": $type,
        reply_depth: replyDepth,
        include_chronological_parent_casts: includeChronologicalParentCasts
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve casts based on filters
 */
export function feed(apiKey: string, feedType: FeedType, { filterType, fid, fids, parentUrl, channelId, embedUrl, withRecasts, limit, cursor, viewerFid }: {
    filterType?: FilterType;
    fid?: Fid;
    fids?: string;
    parentUrl?: string;
    channelId?: string;
    embedUrl?: string;
    withRecasts?: boolean;
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed${QS.query(QS.explode({
        feed_type: feedType,
        filter_type: filterType,
        fid,
        fids,
        parent_url: parentUrl,
        channel_id: channelId,
        embed_url: embedUrl,
        with_recasts: withRecasts,
        limit,
        cursor,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on who a user is following
 */
export function getFarcasterFeedFollowing(apiKey: string, fid: Fid, { viewerFid, withRecasts, limit, cursor }: {
    viewerFid?: Fid;
    withRecasts?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/following${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        with_recasts: withRecasts,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on channel ids
 */
export function getFarcasterFeedChannels(apiKey: string, channelIds: string, { withRecasts, viewerFid, withReplies, limit, cursor }: {
    withRecasts?: boolean;
    viewerFid?: Fid;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/channels${QS.query(QS.explode({
        channel_ids: channelIds,
        with_recasts: withRecasts,
        viewer_fid: viewerFid,
        with_replies: withReplies,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed of casts with Frames, reverse chronological order
 */
export function getFarcasterFeedFrames(apiKey: string, { limit, viewerFid, cursor }: {
    limit?: number;
    viewerFid?: Fid;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/frames${QS.query(QS.explode({
        limit,
        viewer_fid: viewerFid,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve trending casts
 */
export function getFarcasterFeedTrending(apiKey: string, { limit, cursor, viewerFid, timeWindow, channelId }: {
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
    timeWindow?: "1h" | "6h" | "12h" | "24h" | "7d";
    channelId?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/trending${QS.query(QS.explode({
        limit,
        cursor,
        viewer_fid: viewerFid,
        time_window: timeWindow,
        channel_id: channelId
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve 10 most popular casts for a user
 */
export function getFarcasterFeedUserByFidPopular(apiKey: string, fid: Fid, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkCastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/${encodeURIComponent(fid)}/popular${QS.query(QS.explode({
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve recent replies and recasts for a user
 */
export function getFarcasterFeedUserByFidRepliesAndRecasts(apiKey: string, fid: Fid, { limit, cursor, viewerFid }: {
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/${encodeURIComponent(fid)}/replies_and_recasts${QS.query(QS.explode({
        limit,
        cursor,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve a frame by UUID
 */
export function getFarcasterFrame(apiKey: string, uuid: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/frame${QS.query(QS.explode({
        uuid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Create a new frame
 */
export function postFarcasterFrame(apiKey: string, neynarFrameCreationRequest: NeynarFrameCreationRequest, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "POST",
        body: neynarFrameCreationRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update an existing frame
 */
export function putFarcasterFrame(apiKey: string, neynarFrameUpdateRequest: NeynarFrameUpdateRequest, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "PUT",
        body: neynarFrameUpdateRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a frame
 */
export function deleteFarcasterFrame(apiKey: string, body: {
    uuid?: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeleteFrameResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "DELETE",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve a list of frames
 */
export function getFarcasterFrameList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame[];
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a reaction
 */
export function postFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "POST",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a reaction
 */
export function deleteFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Adds verification for an eth address for the user
 */
export function postFarcasterUserVerification(apiKey: string, addVerificationReqBody: AddVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "POST",
        body: addVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Removes verification for an eth address for the user
 */
export function deleteFarcasterUserVerification(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: removeVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Follow a user
 */
export function postFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "POST",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Unfollow a user
 */
export function deleteFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Lookup a user by custody-address
 */
export function getFarcasterUserCustodyAddress(apiKey: string, custodyAddress: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/custody-address${QS.query(QS.explode({
        custody_address: custodyAddress
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch authorization url
 */
export function getFarcasterLoginAuthorize(apiKey: string, clientId: string, responseType: AuthorizationUrlResponseType, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: AuthorizationUrlResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    }>(`/farcaster/login/authorize${QS.query(QS.explode({
        client_id: clientId,
        response_type: responseType
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a frame action
 */
export function postFarcasterFrameAction(apiKey: string, frameActionReqBody: FrameActionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Frame;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/action", oazapfts.json({
        ...opts,
        method: "POST",
        body: frameActionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Validates a frame action against Farcaster Hub
 */
export function postFarcasterFrameValidate(apiKey: string, body: {
    /** Hexadecimal string of message bytes. */
    message_bytes_in_hex: string;
    /** Adds viewer_context inside the cast object to indicate whether the interactor reacted to the cast housing the frame. */
    cast_reaction_context?: boolean;
    /** Adds viewer_context inside the user (interactor) object to indicate whether the interactor follows or is followed by the cast author. */
    follow_context?: boolean;
    /** Adds context about the app used by the user inside `frame.action`. */
    signer_context?: boolean;
    /** Adds context about the channel that the cast belongs to inside of the cast object. */
    channel_follow_context?: boolean;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ValidateFrameActionResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/validate", oazapfts.json({
        ...opts,
        method: "POST",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve a list of all the frames validated by a user
 */
export function getFarcasterFrameValidateList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FrameValidateListResponse;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/validate/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve analytics for the frame
 */
export function getFarcasterFrameValidateAnalytics(apiKey: string, frameUrl: string, analyticsType: ValidateFrameAnalyticsType, start: string, stop: string, { aggregateWindow }: {
    aggregateWindow?: "10s" | "1m" | "2m" | "20m" | "30m" | "2h" | "12h" | "1d" | "7d";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FrameValidateAnalyticsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/frame/validate/analytics${QS.query(QS.explode({
        frame_url: frameUrl,
        analytics_type: analyticsType,
        start,
        stop,
        aggregate_window: aggregateWindow
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a given user
 */
export function notifications(apiKey: string, fid: Fid, { cursor }: {
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications${QS.query(QS.explode({
        fid,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given channels
 */
export function getFarcasterNotificationsChannel(apiKey: string, fid: Fid, channelIds: string, { cursor }: {
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/channel${QS.query(QS.explode({
        fid,
        channel_ids: channelIds,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given parent_urls
 */
export function getFarcasterNotificationsParentUrl(apiKey: string, fid: Fid, parentUrls: string, { cursor }: {
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/parent_url${QS.query(QS.explode({
        fid,
        parent_urls: parentUrls,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve all channels with their details
 */
export function getFarcasterChannelList(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/channel/list${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Search for channels based on id or name
 */
export function getFarcasterChannelSearch(apiKey: string, q: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelSearchResponse;
    }>(`/farcaster/channel/search${QS.query(QS.explode({
        q
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve channel details by id or parent_url
 */
export function getFarcasterChannel(apiKey: string, id: string, { $type, viewerFid }: {
    $type?: ChannelType;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel${QS.query(QS.explode({
        id,
        "type": $type,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve followers for a given channel
 */
export function getFarcasterChannelFollowers(apiKey: string, id: string, { cursor, limit }: {
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/channel/followers${QS.query(QS.explode({
        id,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Get channels that a user is active in
 */
export function getFarcasterChannelUser(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersActiveChannelsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/user${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve users who are active in a channel
 */
export function getFarcasterChannelUsers(apiKey: string, id: string, hasRootCastAuthors: boolean, { hasCastLikers, hasCastRecasters, hasReplyAuthors, cursor, limit }: {
    hasCastLikers?: boolean;
    hasCastRecasters?: boolean;
    hasReplyAuthors?: boolean;
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/users${QS.query(QS.explode({
        id,
        has_root_cast_authors: hasRootCastAuthors,
        has_cast_likers: hasCastLikers,
        has_cast_recasters: hasCastRecasters,
        has_reply_authors: hasReplyAuthors,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve trending channels based on activity
 */
export function getFarcasterChannelTrending(apiKey: string, { timeWindow, limit, cursor }: {
    timeWindow?: "1d" | "7d" | "30d";
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: TrendingChannelResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/channel/trending${QS.query(QS.explode({
        time_window: timeWindow,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve followers for a given user
 */
export function getFarcasterFollowers(apiKey: string, fid: Fid, { viewerFid, sortType, limit, cursor }: {
    viewerFid?: Fid;
    sortType?: FollowSortType;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/followers${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        sort_type: sortType,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve relevant followers for a given user
 */
export function getFarcasterFollowersRelevant(apiKey: string, targetFid: Fid, viewerFid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: RelevantFollowersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/followers/relevant${QS.query(QS.explode({
        target_fid: targetFid,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve a list of users followed by a user
 */
export function getFarcasterFollowing(apiKey: string, fid: Fid, { viewerFid, sortType, limit, cursor }: {
    viewerFid?: Fid;
    sortType?: FollowSortType;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/following${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        sort_type: sortType,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches reactions for a given user
 */
export function getFarcasterReactionsUser(apiKey: string, fid: Fid, $type: ReactionsType, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ReactionsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/reactions/user${QS.query(QS.explode({
        fid,
        "type": $type,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches reactions for a given cast
 */
export function getFarcasterReactionsCast(apiKey: string, hash: CastHash, types: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ReactionsCastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/reactions/cast${QS.query(QS.explode({
        hash,
        types,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Check if a given fname is available
 */
export function getFarcasterFnameAvailability(apiKey: string, fname: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FnameAvailabilityResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/fname/availability${QS.query(QS.explode({
        fname
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage allocations for a given user
 */
export function getFarcasterStorageAllocations(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageAllocationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/allocations${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage usage for a given user
 */
export function getFarcasterStorageUsage(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageUsageResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/usage${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch a webhook
 */
export function getFarcasterWebhook(apiKey: string, webhookId: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/webhook${QS.query(QS.explode({
        webhook_id: webhookId
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Create a webhook
 */
export function postFarcasterWebhook(apiKey: string, webhookPostReqBody: WebhookPostReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "POST",
        body: webhookPostReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update webhook active status
 */
export function patchFarcasterWebhook(apiKey: string, webhookPatchReqBody: WebhookPatchReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "PATCH",
        body: webhookPatchReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update a webhook
 */
export function putFarcasterWebhook(apiKey: string, webhookPutReqBody: WebhookPutReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "PUT",
        body: webhookPutReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a webhook
 */
export function deleteFarcasterWebhook(apiKey: string, webhookDeleteReqBody: WebhookDeleteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: webhookDeleteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetch a list of webhooks associated to a user
 */
export function getFarcasterWebhookList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookListResponse;
    }>("/farcaster/webhook/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Get fids that a user has muted.
 */
export function getFarcasterMuteList(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteListResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/mute/list${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Adds a mute for a fid.
 */
export function postFarcasterMute(apiKey: string, muteReqBody: MuteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/mute", oazapfts.json({
        ...opts,
        method: "POST",
        body: muteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Deletes a mute for a fid.
 */
export function deleteFarcasterMute(apiKey: string, muteReqBody: MuteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/mute", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: muteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
export enum Status {
    PendingApproval = "pending_approval",
    Approved = "approved",
    Revoked = "revoked"
}
export enum Status2 {
    Generated = "generated",
    PendingApproval = "pending_approval",
    Approved = "approved",
    Revoked = "revoked"
}
export enum Object_ {
    User = "user"
}
export enum ActiveStatus {
    Active = "active",
    Inactive = "inactive"
}
export enum Object2 {
    Channel = "channel"
}
export enum CastParamType {
    Url = "url",
    Hash = "hash"
}
export enum CastNotificationType {
    CastMention = "cast-mention",
    CastReply = "cast-reply"
}
export enum FrameButtonActionType {
    Post = "post",
    PostRedirect = "post_redirect",
    Tx = "tx"
}
export enum FeedType {
    Following = "following",
    Filter = "filter"
}
export enum FilterType {
    Fids = "fids",
    ParentUrl = "parent_url",
    ChannelId = "channel_id",
    EmbedUrl = "embed_url",
    GlobalTrending = "global_trending"
}
export enum Aspect_ratio {
    $1911 = "1.91:1",
    $11 = "1:1"
}
export enum Action_type {
    Post = "post",
    PostRedirect = "post_redirect",
    Mint = "mint",
    Link = "link"
}
export enum ReactionType {
    Like = "like",
    Recast = "recast"
}
export enum AuthorizationUrlResponseType {
    Code = "code"
}
export enum Object3 {
    ValidatedFrameAction = "validated_frame_action"
}
export enum ValidateFrameAnalyticsType {
    TotalInteractors = "total-interactors",
    Interactors = "interactors",
    InteractionsPerCast = "interactions-per-cast",
    InputText = "input-text"
}
export enum Type {
    Follows = "follows",
    Recasts = "recasts",
    Likes = "likes",
    Mention = "mention",
    Reply = "reply"
}
export enum Object4 {
    Follow = "follow"
}
export enum Object5 {
    Likes = "likes",
    Recasts = "recasts"
}
export enum Object6 {
    CastDehydrated = "cast_dehydrated"
}
export enum ChannelType {
    Id = "id",
    ParentUrl = "parent_url"
}
export enum Object7 {
    ChannelActivity = "channel_activity"
}
export enum FollowSortType {
    DescChron = "desc_chron",
    Algorithmic = "algorithmic"
}
export enum Object8 {
    Follow = "follow"
}
export enum Object9 {
    UserDehydrated = "user_dehydrated"
}
export enum ReactionsType {
    All = "all",
    Likes = "likes",
    Recasts = "recasts"
}
export enum Reaction_type {
    Like = "like",
    Recast = "recast"
}
export enum Object10 {
    Likes = "likes",
    Recasts = "recasts"
}
export enum Object11 {
    Webhook = "webhook"
}
export enum Object12 {
    WebhookSubscription = "webhook_subscription"
}
export enum Active {
    True = "true",
    False = "false"
}
export enum Object13 {
    Mute = "mute"
}
