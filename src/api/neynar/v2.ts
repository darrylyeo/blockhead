/**
 * Farcaster API V2
 * 2.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "@oazapfts/runtime";
import * as QS from "@oazapfts/runtime/query";
export const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders> = {
    headers: {},
    baseUrl: "https://api.neynar.com/v2",
};
const oazapfts = Oazapfts.runtime(defaults);
export const servers = {
    server1: "https://api.neynar.com/v2"
};
export type UserFidResponse = {
    fid: number;
};
export type ErrorRes = {
    code?: string;
    message: string;
    property?: string;
    status?: number;
};
export type Ed25519PublicKey = string;
export type Fid = number;
export type DeveloperManagedSigner = {
    public_key: Ed25519PublicKey;
    status: Status;
    signer_approval_url?: string;
    fid?: Fid;
};
export type RegisterDeveloperManagedSignedKeyReqBody = {
    public_key: Ed25519PublicKey;
    /** Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key */
    signature: string;
    /** Application FID */
    app_fid: Fid;
    /** unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended) */
    deadline: number;
    sponsor?: {
        /** FID of the sponsor */
        fid: Fid;
        /** Signature generated by the fid of the sponsor and the signature generated from signKeyRequest for the app. */
        signature: string;
    };
};
export type SignerUuid = string;
export type Signer = {
    signer_uuid: SignerUuid;
    public_key: Ed25519PublicKey;
    status: Status2;
    signer_approval_url?: string;
    fid?: Fid;
};
export type RegisterSignerKeyReqBody = {
    signer_uuid: SignerUuid;
    /** Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signer’s public key */
    signature: string;
    /** Application FID */
    app_fid: Fid;
    /** unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended) */
    deadline: number;
    sponsor?: {
        /** FID of the sponsor */
        fid: Fid;
        /** Signature generated by the fid of the sponsor and the signature generated from signKeyRequest for the app. */
        signature: string;
    };
};
export type Address = string;
export type SolAddress = string;
export type UserViewerContext = {
    /** Indicates if the viewer is following the user. */
    following: boolean;
    /** Indicates if the viewer is followed by the user. */
    followed_by: boolean;
};
export type User = {
    "object": Object_;
    fid: Fid;
    username: string;
    display_name?: string;
    custody_address: Address;
    /** The URL of the user's profile picture */
    pfp_url?: string;
    profile: {
        bio: {
            text: string;
            mentioned_profiles: string[];
        };
    };
    /** The number of followers the user has. */
    follower_count: number;
    /** The number of users the user is following. */
    following_count: number;
    verifications: Address[];
    verified_addresses: {
        eth_addresses: Address[];
        sol_addresses: SolAddress[];
    };
    active_status: ActiveStatus;
    power_badge: boolean;
    viewer_context?: UserViewerContext;
};
export type ProfileUrl = {
    pfp: {
        url: string;
    };
};
export type SearchedUser = User & ProfileUrl;
export type NextCursor = {
    cursor: string | null;
};
export type UserSearchResponse = {
    result: {
        users: SearchedUser[];
        next?: NextCursor;
    };
};
export type BulkUsersResponse = {
    users: User[];
};
export type UsersResponse = {
    users: User[];
    next: NextCursor;
};
export type Fids = Fid[];
export type UserPowerLiteResponse = {
    result: {
        fids: Fids;
    };
};
export type BulkUsersByAddressResponse = {
    [key: string]: User[];
};
export type ChannelViewerContext = {
    /** Indicates if the viewer is following the channel. */
    following: boolean;
};
export type Channel = {
    id: string;
    url: string;
    name?: string;
    description?: string;
    "object": Object2;
    /** Epoch timestamp in seconds. */
    created_at?: number;
    /** Number of followers the channel has. */
    follower_count?: number;
    image_url?: string;
    parent_url?: string;
    lead?: User;
    moderator?: User;
    hosts?: User[];
    viewer_context?: ChannelViewerContext;
};
export type ChannelListResponse = {
    channels: Channel[];
    next?: NextCursor;
};
export type UpdateUserReqBody = {
    signer_uuid: SignerUuid;
    bio?: string;
    pfp_url?: string;
    url?: string;
    username?: string;
    display_name?: string;
};
export type OperationResponse = {
    success: boolean;
    message?: string;
};
export type RegisterUserReqBody = {
    signature: string;
    fid: number;
    requested_user_custody_address: string;
    deadline: number;
    fname?: string;
};
export type RegisterUserResponse = {
    success: true;
    message: string;
    signer: Signer;
};
export type ConflictErrorRes = {
    code?: string;
    message: string;
    property?: string;
    key?: string;
};
export type PublishMessageReqBody = object;
export type PublishMessageResponse = object;
export type Timestamp = string;
export type MusicSongObject = {
    disc?: string;
    track?: number;
    url: string;
};
export type ImageObject = {
    height?: number;
    "type"?: string;
    url: string;
    width?: number;
    alt?: string;
};
export type VideoObject = {
    height?: number;
    "type"?: string;
    url: string;
    width?: number;
};
export type TwitterImageObject = {
    alt?: string;
    height?: number;
    url: string;
    width?: number;
};
export type TwitterPlayerObject = {
    height?: number;
    stream?: string;
    url: string;
    width?: number;
};
export type OgObject = {
    alAndroidAppName?: string;
    alAndroidClass?: string;
    alAndroidPackage?: string;
    alAndroidUrl?: string;
    alIosAppName?: string;
    alIosAppStoreId?: string;
    alIosUrl?: string;
    alIpadAppName?: string;
    alIpadAppStoreId?: string;
    alIpadUrl?: string;
    alIphoneAppName?: string;
    alIphoneAppStoreId?: string;
    alIphoneUrl?: string;
    alWebShouldFallback?: string;
    alWebUrl?: string;
    alWindowsAppId?: string;
    alWindowsAppName?: string;
    alWindowsPhoneAppId?: string;
    alWindowsPhoneAppName?: string;
    alWindowsPhoneUrl?: string;
    alWindowsUniversalAppId?: string;
    alWindowsUniversalAppName?: string;
    alWindowsUniversalUrl?: string;
    alWindowsUrl?: string;
    articleAuthor?: string;
    articleExpirationTime?: string;
    articleModifiedTime?: string;
    articlePublishedDate?: string;
    articlePublishedTime?: string;
    articleModifiedDate?: string;
    articlePublisher?: string;
    articleSection?: string;
    articleTag?: string;
    author?: string;
    bookAuthor?: string;
    bookCanonicalName?: string;
    bookIsbn?: string;
    bookReleaseDate?: string;
    booksBook?: string;
    booksRatingScale?: string;
    booksRatingValue?: string;
    bookTag?: string;
    businessContactDataCountryName?: string;
    businessContactDataLocality?: string;
    businessContactDataPostalCode?: string;
    businessContactDataRegion?: string;
    businessContactDataStreetAddress?: string;
    charset?: string;
    dcContributor?: string;
    dcCoverage?: string;
    dcCreator?: string;
    dcDate?: string;
    dcDateCreated?: string;
    dcDateIssued?: string;
    dcDescription?: string;
    dcFormatMedia?: string;
    dcFormatSize?: string;
    dcIdentifier?: string;
    dcLanguage?: string;
    dcPublisher?: string;
    dcRelation?: string;
    dcRights?: string;
    dcSource?: string;
    dcSubject?: string;
    dcTitle?: string;
    dcType?: string;
    favicon?: string;
    fbAppId?: string;
    jsonLD?: object[];
    modifiedTime?: string;
    musicAlbum?: string;
    musicAlbumDisc?: string;
    musicAlbumTrack?: string;
    musicAlbumUrl?: string;
    musicCreator?: string;
    musicDuration?: string;
    musicMusician?: string;
    musicPlaylist?: string;
    musicRadioStation?: string;
    musicReleaseDate?: string;
    musicSong?: MusicSongObject[];
    ogArticleAuthor?: string;
    ogArticleExpirationTime?: string;
    ogArticleModifiedTime?: string;
    ogArticlePublishedTime?: string;
    ogArticlePublisher?: string;
    ogArticleSection?: string;
    ogArticleTag?: string;
    ogAudio?: string;
    ogAudioSecureURL?: string;
    ogAudioType?: string;
    ogAudioURL?: string;
    ogAvailability?: string;
    ogDate?: string;
    ogDescription?: string;
    ogDeterminer?: string;
    ogEpisode?: string;
    ogImage?: ImageObject[];
    ogLocale?: string;
    ogLocaleAlternate?: string;
    ogLogo?: string;
    ogMovie?: string;
    ogPriceAmount?: string;
    ogPriceCurrency?: string;
    ogProductAvailability?: string;
    ogProductCondition?: string;
    ogProductPriceAmount?: string;
    ogProductPriceCurrency?: string;
    ogProductRetailerItemId?: string;
    ogSiteName?: string;
    ogTitle?: string;
    ogType?: string;
    ogUrl?: string;
    ogVideo?: VideoObject[];
    ogVideoActor?: string;
    ogVideoActorId?: string;
    ogVideoActorRole?: string;
    ogVideoDirector?: string;
    ogVideoDuration?: string;
    ogVideoOther?: string;
    ogVideoReleaseDate?: string;
    ogVideoSecureURL?: string;
    ogVideoSeries?: string;
    ogVideoTag?: string;
    ogVideoTvShow?: string;
    ogVideoWriter?: string;
    ogWebsite?: string;
    placeLocationLatitude?: string;
    placeLocationLongitude?: string;
    profileFirstName?: string;
    profileGender?: string;
    profileLastName?: string;
    profileUsername?: string;
    publishedTime?: string;
    releaseDate?: string;
    requestUrl?: string;
    restaurantContactInfoCountryName?: string;
    restaurantContactInfoEmail?: string;
    restaurantContactInfoLocality?: string;
    restaurantContactInfoPhoneNumber?: string;
    restaurantContactInfoPostalCode?: string;
    restaurantContactInfoRegion?: string;
    restaurantContactInfoStreetAddress?: string;
    restaurantContactInfoWebsite?: string;
    restaurantMenu?: string;
    restaurantRestaurant?: string;
    restaurantSection?: string;
    restaurantVariationPriceAmount?: string;
    restaurantVariationPriceCurrency?: string;
    twitterAccount?: string;
    twitterAppIdGooglePlay?: string;
    twitterAppIdiPad?: string;
    twitterAppIdiPhone?: string;
    twitterAppNameGooglePlay?: string;
    twitterAppNameiPad?: string;
    twitterAppNameiPhone?: string;
    twitterAppUrlGooglePlay?: string;
    twitterAppUrliPad?: string;
    twitterAppUrliPhone?: string;
    twitterCard?: string;
    twitterCreator?: string;
    twitterCreatorId?: string;
    twitterDescription?: string;
    twitterImage?: TwitterImageObject[];
    twitterPlayer?: TwitterPlayerObject[];
    twitterPlayerStreamContentType?: string;
    twitterSite?: string;
    twitterSiteId?: string;
    twitterTitle?: string;
    twitterUrl?: string;
    updatedTime?: string;
};
export type EmbedUrlMetadata = {
    _status: string;
    content_type?: string | null;
    content_length?: number | null;
    image?: {
        height_px?: number;
        width_px?: number;
    };
    video?: {
        duration_s?: number;
        stream?: {
            codec_name?: string;
            height_px?: number;
            width_px?: number;
        }[];
    };
    html?: OgObject;
};
export type EmbedUrl = {
    url: string;
    metadata?: EmbedUrlMetadata;
};
export type CastId = {
    fid: Fid;
    hash: string;
};
export type EmbedCastId = {
    cast_id: CastId;
};
export type EmbeddedCast = EmbedUrl | EmbedCastId;
export type Cast = {
    hash: string;
    parent_hash: string | null;
    parent_url: string | null;
    root_parent_url: string | null;
    parent_author: Fid & {
        fid: number | null;
    };
    author: User;
    text: string;
    timestamp: Timestamp;
    embeds: EmbeddedCast[];
    "type"?: CastNotificationType;
};
export type FrameActionButton = {
    /** Title of the button */
    title?: string;
    /** Index of the button */
    index: number;
    action_type: FrameButtonActionType;
    /** Target of the button */
    target?: string;
    /** Used specifically for the tx action type to post a successful transaction hash */
    post_url?: string;
};
export type Frame = {
    /** Version of the frame */
    version: string;
    /** URL of the image */
    image: string;
    buttons?: FrameActionButton[];
    /** Post URL to take an action on this frame */
    post_url?: string;
    /** URL of the frames */
    frames_url: string;
    title?: string;
    image_aspect_ratio?: string;
    input?: {
        /** Input text for the frame */
        text?: string;
    };
    state?: {
        /** State for the frame in a serialized format */
        serialized?: string;
    };
};
export type ReactionLike = {
    fid: Fid;
};
export type ReactionRecast = {
    fid: Fid;
    fname: string;
};
export type CastWithInteractionsReactions = {
    likes: ReactionLike[];
    recasts: ReactionRecast[];
    likes_count: number;
    recasts_count: number;
};
export type CastWithInteractionsReplies = {
    count: number;
};
export type DehydratedChannel = {
    id: string;
    name: string;
    "object": Object3;
    image_url?: string;
};
export type ChannelOrDehydratedChannel = ({
    "type": "channel";
} & Channel) | ({
    "type": "dehydratedChannel";
} & DehydratedChannel);
export type CastViewerContext = {
    /** Indicates if the viewer liked the cast. */
    liked: boolean;
    /** Indicates if the viewer recasted the cast. */
    recasted: boolean;
};
export type CastWithInteractions = Cast & object & {
    frames?: Frame[];
    reactions: CastWithInteractionsReactions;
    replies: CastWithInteractionsReplies;
    thread_hash: string | null;
    mentioned_profiles: User[];
    channel: ChannelOrDehydratedChannel;
    viewer_context?: CastViewerContext;
};
export type CastResponse = {
    cast: CastWithInteractions;
};
export type CastParent = string;
export type Idem = string;
export type PostCastReqBody = {
    signer_uuid: SignerUuid;
    text?: string;
    embeds?: EmbeddedCast[];
    parent?: CastParent;
    /** Channel ID of the channel where the cast is to be posted. e.g. neynar, farcaster, warpcast */
    channel_id?: string;
    idem?: Idem;
    parent_author_fid?: Fid;
};
export type PostCastResponse = {
    success: boolean;
    cast: {
        hash: Address;
        author: {
            fid: Fid;
        };
        text: string;
    };
};
export type DeleteCastReqBody = {
    signer_uuid: SignerUuid;
    target_hash: Address;
};
export type CastsResponse = {
    result: {
        casts: CastWithInteractions[];
    };
};
export type ReplyDepth = number;
export type CastWithInteractionsAndConversations = CastWithInteractions & {
    /** note: This is recursive. It contains the direct replies to the cast and their direct replies up to n reply_depth. */
    direct_replies?: CastWithInteractionsAndConversations[];
};
export type Conversation = {
    conversation: {
        cast: CastWithInteractionsAndConversations;
        chronological_parent_casts?: CastWithInteractions[];
    };
    next?: NextCursor;
};
export type FeedResponse = {
    casts: CastWithInteractions[];
    next: NextCursor;
};
export type SubscriptionTier = {
    id?: number;
    price?: {
        period_duration_seconds?: number;
        tokens_per_period?: string;
        initial_mint_price?: string;
    };
};
export type Subscription = {
    "object": string;
    provider_name?: string;
    contract_address: string;
    chain: number;
    metadata: {
        title: string;
        "symbol": string;
        art_url: string;
    };
    owner_address: string;
    price: {
        period_duration_seconds: number;
        tokens_per_period: string;
        initial_mint_price: string;
    };
    tiers?: SubscriptionTier[];
    protocol_version: number;
    token: {
        "symbol": string;
        address: string | null;
        decimals: number;
        erc20: boolean;
    };
};
export type Subscriptions = {
    "object": string;
    subscriptions_created: Subscription[];
};
export type SubscriptionsResponse = {
    subscriptions_created?: Subscriptions[];
};
export type SubscribedTo = Subscription & {
    expires_at?: string;
    subscribed_at?: string;
    tier?: SubscriptionTier;
    creator?: User;
};
export type SubscribedToResponse = {
    subscribed_to?: SubscribedTo[];
};
export type SubscribedToObject = {
    "object": string;
    provider_name: string;
    contract_address?: string;
    protocol_version?: number;
    chain?: number;
    expires_at?: string;
    subscribed_at?: string;
    tier_id?: string;
};
export type Subscriber = {
    "object": string;
    user: User;
    subscribed_to: SubscribedToObject;
};
export type SubscribersResponse = {
    subscribers?: Subscriber[];
};
export type ZodError = {
    message: string;
    code: string;
    errors: {
        code: string;
        expected: string;
        received: string;
        path: string[];
        message: string;
    }[];
};
export type BulkCastsResponse = {
    casts: CastWithInteractions[];
};
export type NeynarPageImage = {
    /** The URL of the page's image. */
    url: string;
    /** The aspect ratio of the image. */
    aspect_ratio: Aspect_ratio;
};
export type NeynarNextFramePage = {
    /** The UUID of the next page. */
    uuid: string;
};
export type NeynarNextFramePageRedirect = {
    /** The URL to redirect to. */
    redirect_url: string;
};
export type NeynarNextFramePageMintUrl = {
    /** The URL for minting, specific to the mint action. */
    mint_url: string;
};
export type NeynarPageButton = {
    /** The title of the button. */
    title: string;
    /** The index of the button, first button should have index 1 and so on. */
    index: number;
    /** The type of action that the button performs. */
    action_type: Action_type;
    next_page?: NeynarNextFramePage | NeynarNextFramePageRedirect | NeynarNextFramePageMintUrl;
};
export type NeynarPageInput = {
    text?: {
        /** Indicates if text input is enabled. */
        enabled: boolean;
        /** The placeholder text for the input. */
        placeholder?: string;
    };
};
export type NeynarFramePage = {
    /** Unique identifier for the page. */
    uuid: string;
    /** The version of the page schema. */
    version: string;
    /** The title of the page. */
    title: string;
    image: NeynarPageImage;
    buttons?: NeynarPageButton[];
    input?: NeynarPageInput;
};
export type NeynarFrame = {
    /** Unique identifier for the frame. */
    uuid: string;
    /** Name of the frame. */
    name: string;
    /** Generated link for the frame's first page. */
    link: string;
    pages: NeynarFramePage[];
    /** Indicates if the frame is valid. */
    valid?: boolean;
};
export type NeynarFrameCreationRequest = {
    /** The name of the frame. */
    name: string;
    pages: NeynarFramePage[];
};
export type NeynarFrameUpdateRequest = {
    /** The UUID of the frame to update. */
    uuid: string;
    /** The name of the frame. */
    name?: string;
    pages: NeynarFramePage[];
};
export type DeleteFrameResponse = {
    success?: boolean;
    uuid?: string;
};
export type ReactionReqBody = {
    signer_uuid: SignerUuid;
    reaction_type: ReactionType;
    target: string;
    /** If the target is a cast hash, this value should indicate the target cast's author's fid (unsigned integer) */
    target_author_fid?: Fid;
    idem?: Idem;
};
export type AddVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
    block_hash: string;
    eth_signature: string;
    verification_type?: VerificationType;
    chain_id?: VerificationChainId;
};
export type RemoveVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
};
export type FollowReqBody = {
    signer_uuid: SignerUuid;
    target_fids: Fid[];
};
export type FollowResponse = {
    success: boolean;
    target_fid: Fid;
    hash: string;
};
export type BulkFollowResponse = {
    success: boolean;
    details: FollowResponse[];
};
export type UserResponse = {
    user: User;
};
export type AuthorizationUrlResponse = {
    authorization_url: string;
};
export type CastHash = string;
export type FrameInput = {
    /** Input text for the frame */
    text?: string;
};
export type FrameState = {
    /** State for the frame in a serialized format */
    serialized: string;
};
export type FrameTransaction = {
    /** Transaction hash */
    hash: string;
};
export type FrameAddress = string;
export type FrameAction = {
    version?: string;
    title?: string;
    image?: string;
    button: FrameActionButton;
    input?: FrameInput;
    state?: FrameState;
    transaction?: FrameTransaction;
    address?: FrameAddress;
    /** URL of the frames */
    frames_url: string;
    /** URL of the post to get the next frame */
    post_url: string;
};
export type FrameSignaturePacket = {
    /** Untrusted data from the user */
    untrustedData: {
        fid?: Fid;
        /** URL of the frame */
        url?: string;
        /** Message hash */
        messageHash?: string;
        /** Timestamp */
        timestamp?: string;
        /** Network */
        network?: number;
        /** Index of the button */
        buttonIndex?: number;
        /** Input text */
        inputText?: string;
        /** State */
        state?: string;
        /** Transaction ID */
        transactionId?: string;
        address?: Address;
        castId?: CastId;
    };
    /** Trusted data from the user */
    trustedData: {
        /** Message bytes */
        messageBytes?: string;
    };
};
export type FrameDeveloperManagedActionReqBody = {
    cast_hash?: CastHash;
    action: FrameAction;
    signature_packet: FrameSignaturePacket;
};
export type FrameActionReqBody = {
    signer_uuid: SignerUuid;
    cast_hash?: CastHash;
    action: FrameAction;
};
export type ValidatedFrameAction = {
    "object": Object4;
    url: string;
    interactor: User;
    tapped_button: {
        index: number;
    };
    input?: FrameInput;
    state: FrameState;
    cast: CastWithInteractions;
    timestamp: Timestamp;
    signer?: {
        client?: User;
    };
    transaction?: FrameTransaction;
    address?: FrameAddress;
};
export type ValidateFrameActionResponse = {
    valid: boolean;
    action: ValidatedFrameAction;
};
export type FrameValidateListResponse = {
    frames: string[];
};
export type FrameValidateAnalyticsInteractors = {
    interactors: {
        fid: Fid;
        username: string;
        interaction_count: number;
    }[];
};
export type FrameValidateAnalyticsTotalInteractors = {
    total_interactors: number;
};
export type FrameValidateAnalyticsInteractionsPerCast = {
    interactions_per_cast: {
        start: string;
        stop: string;
        time: string;
        interaction_count: number;
        cast_url: string;
    }[];
};
export type FrameValidateAnalyticsInputText = {
    input_texts: {
        fid: Fid;
        username: string;
        input_text: string;
    }[];
};
export type FrameValidateAnalyticsResponse = FrameValidateAnalyticsInteractors | FrameValidateAnalyticsTotalInteractors | FrameValidateAnalyticsInteractionsPerCast | FrameValidateAnalyticsInputText;
export type Follow = {
    "object": Object5;
    user: User;
};
export type CastDehydrated = {
    hash: string;
    "object": Object7;
};
export type ReactionWithUserInfo = {
    "object": Object6;
    cast: CastDehydrated;
    user: User;
};
export type Notification = {
    "object": string;
    most_recent_timestamp: string;
    "type": Type;
    follows?: Follow[];
    cast?: CastWithInteractions;
    reactions?: ReactionWithUserInfo[];
};
export type NotificationsResponse = {
    notifications: Notification[];
    next: NextCursor;
};
export type ChannelSearchResponse = {
    channels: Channel[];
};
export type ChannelResponseBulk = {
    channels: Channel[];
};
export type ChannelResponse = {
    channel: Channel;
};
export type UsersActiveChannelsResponse = {
    channels?: Channel[];
    next?: NextCursor;
};
export type ChannelActivity = {
    "object": Object8;
    cast_count_1d: string;
    cast_count_7d: string;
    cast_count_30d: string;
    channel: Channel;
};
export type TrendingChannelResponse = {
    channels: ChannelActivity[];
    next: NextCursor;
};
export type HydratedFollower = {
    "object"?: Object9;
    user?: User;
};
export type UserDehydrated = {
    "object": Object10;
    fid: Fid;
};
export type DehydratedFollower = {
    "object"?: Object9;
    user?: UserDehydrated;
};
export type RelevantFollowersResponse = {
    top_relevant_followers_hydrated: HydratedFollower[];
    all_relevant_followers_dehydrated: DehydratedFollower[];
};
export type ReactionWithCastInfo = {
    reaction_type: Reaction_type;
    cast: CastWithInteractions;
    reaction_timestamp: string;
    "object": Object11;
    user: UserDehydrated;
};
export type ReactionsResponse = {
    reactions: ReactionWithCastInfo[];
    next: NextCursor;
};
export type ReactionForCast = {
    reaction_type: Reaction_type;
    reaction_timestamp: string;
    "object": Object11;
    user: User;
};
export type ReactionsCastResponse = {
    reactions: ReactionForCast[];
    next: NextCursor;
};
export type FnameAvailabilityResponse = {
    available: boolean;
};
export type StorageAllocation = {
    "object"?: string;
    user?: UserDehydrated;
    units?: number;
    expiry?: string;
    timestamp?: string;
};
export type StorageAllocationsResponse = {
    total_active_units?: number;
    allocations?: StorageAllocation[];
};
export type StorageObject = {
    "object"?: string;
    used?: number;
    capacity?: number;
};
export type StorageUsageResponse = {
    "object"?: string;
    user?: UserDehydrated;
    casts?: StorageObject;
    reactions?: StorageObject;
    links?: StorageObject;
    verified_addresses?: StorageObject;
    username_proofs?: StorageObject;
    signers?: StorageObject;
    total_active_units?: number;
};
export type BuyStorageReqBody = {
    fid: number;
    /** Number of storage units to buy.
    A storage unit lets you store 5000 casts, 2500 reactions and 2500 links.
     */
    units?: number;
    idem?: Idem;
};
export type WebhookSecret = {
    uid: string;
    value: string;
    expires_at: string;
    created_at: string;
    updated_at: string;
    deleted_at: string;
};
export type WebhookSubscriptionFiltersFollow = {
    fids?: number[];
    target_fids?: number[];
};
export type WebhookSubscriptionFiltersReaction = {
    fids?: number[];
    target_fids?: number[];
};
export type WebhookSubscriptionFilters = {
    "cast.created"?: {
        /** Exclude casts that matches these authors.
        **Note:**
        This is applied as an AND operation against rest of the filters.
        Rest of the filters are bundled as an OR operation.
         */
        exclude_author_fids?: number[];
        author_fids?: number[];
        mentioned_fids?: number[];
        parent_urls?: string[];
        root_parent_urls?: string[];
        parent_hashes?: string[];
        parent_author_fids?: number[];
        /** Regex pattern to match the text key of the cast.
        **Note:**
        1) Regex must be parsed by Go's RE2 engine (Test your expression here: https://www.lddgo.net/en/string/golangregex)
        2) Use backslashes to escape special characters.
        For example: (?i)\\$degen should be written as (?i)\\\\$degen
         */
        text?: string;
        /** Regex pattern to match the embeded_url (key embeds) of the cast.
        **Note:**
        1) Regex must be parsed by Go's RE2 engine (Test your expression here: https://www.lddgo.net/en/string/golangregex)
        2) Use backslashes to escape special characters.
        For example: \\b(farcaster|neynar)\\b should be written as \\\\b(farcaster|neynar)\\\\b
         */
        embeds?: string;
    };
    "user.created"?: object;
    "user.updated"?: {
        fids?: number[];
    };
    "follow.created"?: WebhookSubscriptionFiltersFollow;
    "follow.deleted"?: WebhookSubscriptionFiltersFollow;
    "reaction.created"?: WebhookSubscriptionFiltersReaction;
    "reaction.deleted"?: WebhookSubscriptionFiltersReaction;
};
export type WebhookSubscription = {
    "object": Object13;
    subscription_id: string;
    filters: WebhookSubscriptionFilters;
    created_at: string;
    updated_at: string;
};
export type Webhook = {
    "object": Object12;
    webhook_id: string;
    developer_uuid: string;
    target_url: string;
    title: string;
    secrets: WebhookSecret[];
    description: string;
    http_timeout: string;
    rate_limit: number;
    active: boolean;
    rate_limit_duration: string;
    created_at: string;
    updated_at: string;
    deleted_at: string;
    subscription?: WebhookSubscription;
};
export type WebhookResponse = {
    message?: string;
    success?: boolean;
    webhook?: Webhook;
};
export type WebhookPostReqBody = {
    name: string;
    url: string;
    subscription?: WebhookSubscriptionFilters;
};
export type WebhookPatchReqBody = {
    webhook_id: string;
    active: Active;
};
export type WebhookPutReqBody = WebhookPostReqBody & {
    webhook_id: string;
};
export type WebhookDeleteReqBody = {
    webhook_id: string;
};
export type WebhookListResponse = {
    webhooks: Webhook[];
};
export type MuteList = {
    "object": Object14;
    muted: User;
    muted_at: Timestamp;
};
export type MuteListResponse = {
    mutes: MuteList[];
    next: NextCursor;
};
export type MuteReqBody = {
    fid: Fid;
    muted_fid: Fid;
};
export type MuteResponse = {
    success: boolean;
    message?: string;
};
export type CastComposerActionsListResponse = {
    actions?: {
        /** The name of the action. */
        name?: string;
        /** The icon representing the action. */
        icon?: string;
        /** A brief description of the action. */
        description?: string;
        /** URL to learn more about the action. */
        about_url?: string;
        /** URL of the action's image. */
        image_url?: string;
        /** URL to perform the action. */
        action_url?: string;
        action?: {
            /** Type of the action (e.g., post). */
            action_type?: string;
            /** URL to post the action. */
            post_url?: string;
        };
        /** Icon name for the action. */
        octicon?: string;
        /** Number of times the action has been added. */
        added_count?: number;
        /** Name of the application providing the action. */
        app_name?: string;
        /** Author's Farcaster ID. */
        author_fid?: number;
        /** Category of the action. */
        category?: string;
        /** Object type, which is "composer_action". */
        "object"?: string;
    }[];
    next?: NextCursor;
};
/**
 * Fetches fid to assign it new user
 */
export function getFarcasterUserFid(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserFidResponse;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/fid", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches the status of a signer by public key
 */
export function getFarcasterSignerDeveloperManaged(apiKey: string, publicKey: Ed25519PublicKey, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeveloperManagedSigner;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/signer/developer_managed${QS.query(QS.explode({
        public_key: publicKey
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Registers Signed Key
 */
export function postFarcasterSignerDeveloperManagedSignedKey(apiKey: string, registerDeveloperManagedSignedKeyReqBody: RegisterDeveloperManagedSignedKeyReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeveloperManagedSigner;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer/developer_managed/signed_key", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerDeveloperManagedSignedKeyReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetches the status of a signer
 */
export function signer(apiKey: string, signerUuid: SignerUuid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/signer${QS.query(QS.explode({
        signer_uuid: signerUuid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Creates a signer and returns the signer status
 */
export function postFarcasterSigner(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer", {
        ...opts,
        method: "POST",
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Register Signed Key
 */
export function postFarcasterSignerSignedKey(apiKey: string, registerSignerKeyReqBody: RegisterSignerKeyReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer/signed_key", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerSignerKeyReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Search for Usernames
 */
export function getFarcasterUserSearch(apiKey: string, q: string, { viewerFid, limit, cursor }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserSearchResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/search${QS.query(QS.explode({
        q,
        viewer_fid: viewerFid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch users based on FIDs
 */
export function getFarcasterUserBulk(apiKey: string, fids: string, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/bulk${QS.query(QS.explode({
        fids,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch power user objects
 */
export function getFarcasterUserPower(apiKey: string, { viewerFid, limit, cursor }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/power${QS.query(QS.explode({
        viewer_fid: viewerFid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch power user FIDs
 */
export function getFarcasterUserPowerLite(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserPowerLiteResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/power_lite", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch active users
 */
export function getFarcasterUserActive(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/active${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches users based on Eth or Sol addresses
 */
export function getFarcasterUserBulkByAddress(apiKey: string, addresses: string, { addressTypes, viewerFid }: {
    addressTypes?: string;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersByAddressResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/bulk-by-address${QS.query(QS.explode({
        addresses,
        address_types: addressTypes,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve all channels that a given fid follows
 */
export function getFarcasterUserChannels(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/user/channels${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Update user profile
 */
export function patchFarcasterUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user", oazapfts.json({
        ...opts,
        method: "PATCH",
        body: updateUserReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Register account on farcaster
 */
export function postFarcasterUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: RegisterUserResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 409;
        data: ConflictErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerUserReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Publish a message to farcaster
 */
export function postFarcasterMessage(apiKey: string, publishMessageReqBody: PublishMessageReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PublishMessageResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/message", oazapfts.json({
        ...opts,
        method: "POST",
        body: publishMessageReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve cast for a given hash or Warpcast URL
 */
export function cast(apiKey: string, identifier: string, $type: CastParamType, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast${QS.query(QS.explode({
        identifier,
        "type": $type,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a cast
 */
export function postFarcasterCast(apiKey: string, postCastReqBody: PostCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PostCastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "POST",
        body: postCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a cast
 */
export function deleteFarcasterCast(apiKey: string, deleteCastReqBody: DeleteCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: deleteCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Gets information about an array of casts
 */
export function casts(apiKey: string, casts: string, { viewerFid, sortType }: {
    viewerFid?: Fid;
    sortType?: "trending" | "likes" | "recasts" | "replies" | "recent";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/casts${QS.query(QS.explode({
        casts,
        viewer_fid: viewerFid,
        sort_type: sortType
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Search for casts
 */
export function getFarcasterCastSearch(apiKey: string, q: string, { authorFid, parentUrl, channelId, limit, cursor }: {
    authorFid?: Fid;
    parentUrl?: string;
    channelId?: string;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast/search${QS.query(QS.explode({
        q,
        author_fid: authorFid,
        parent_url: parentUrl,
        channel_id: channelId,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve the conversation for a given cast
 */
export function getFarcasterCastConversation(apiKey: string, identifier: string, $type: CastParamType, { replyDepth, includeChronologicalParentCasts, viewerFid, limit, cursor }: {
    replyDepth?: ReplyDepth;
    includeChronologicalParentCasts?: boolean;
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Conversation;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast/conversation${QS.query(QS.explode({
        identifier,
        "type": $type,
        reply_depth: replyDepth,
        include_chronological_parent_casts: includeChronologicalParentCasts,
        viewer_fid: viewerFid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve casts based on filters
 */
export function feed(apiKey: string, feedType: FeedType, { filterType, fid, fids, parentUrl, channelId, embedUrl, withRecasts, limit, cursor, viewerFid }: {
    filterType?: FilterType;
    fid?: Fid;
    fids?: string;
    parentUrl?: string;
    channelId?: string;
    embedUrl?: string;
    withRecasts?: boolean;
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed${QS.query(QS.explode({
        feed_type: feedType,
        filter_type: filterType,
        fid,
        fids,
        parent_url: parentUrl,
        channel_id: channelId,
        embed_url: embedUrl,
        with_recasts: withRecasts,
        limit,
        cursor,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on who a user is following
 */
export function getFarcasterFeedFollowing(apiKey: string, fid: Fid, { viewerFid, withRecasts, limit, cursor }: {
    viewerFid?: Fid;
    withRecasts?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/following${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        with_recasts: withRecasts,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve a personalized For You feed for a user
 */
export function getFarcasterFeedForYou(apiKey: string, fid: Fid, { viewerFid, provider, limit, cursor }: {
    viewerFid?: Fid;
    provider?: ForYouProvider;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/for_you${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        provider,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch created subscriptions for a given fid
 */
export function getFarcasterUserSubscriptionsCreated(apiKey: string, fid: Fid, subscriptionProvider: SubscriptionProvider, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: SubscriptionsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/subscriptions_created${QS.query(QS.explode({
        fid,
        subscription_provider: subscriptionProvider
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch what a given fid is subscribed to
 */
export function getFarcasterUserSubscribedTo(apiKey: string, fid: Fid, subscriptionProvider: SubscriptionProvider, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: SubscribedToResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/subscribed_to${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        subscription_provider: subscriptionProvider
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch subscribers for a given fid
 */
export function subscribers(apiKey: string, fid: Fid, subscriptionProvider: SubscriptionProviders, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: SubscribersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/subscribers${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        subscription_provider: subscriptionProvider
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on channel ids
 */
export function getFarcasterFeedChannels(apiKey: string, channelIds: string, { withRecasts, viewerFid, withReplies, limit, cursor, shouldModerate }: {
    withRecasts?: boolean;
    viewerFid?: Fid;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
    shouldModerate?: boolean;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/channels${QS.query(QS.explode({
        channel_ids: channelIds,
        with_recasts: withRecasts,
        viewer_fid: viewerFid,
        with_replies: withReplies,
        limit,
        cursor,
        should_moderate: shouldModerate
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on parent urls
 */
export function getFarcasterFeedParentUrls(apiKey: string, parentUrls: string, { withRecasts, viewerFid, withReplies, limit, cursor }: {
    withRecasts?: boolean;
    viewerFid?: Fid;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/parent_urls${QS.query(QS.explode({
        parent_urls: parentUrls,
        with_recasts: withRecasts,
        viewer_fid: viewerFid,
        with_replies: withReplies,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed of casts with Frames, reverse chronological order
 */
export function getFarcasterFeedFrames(apiKey: string, { limit, viewerFid, cursor }: {
    limit?: number;
    viewerFid?: Fid;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/frames${QS.query(QS.explode({
        limit,
        viewer_fid: viewerFid,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve trending casts
 */
export function getFarcasterFeedTrending(apiKey: string, { limit, cursor, viewerFid, timeWindow, channelId, provider }: {
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
    timeWindow?: "1h" | "6h" | "12h" | "24h" | "7d";
    channelId?: string;
    provider?: FeedTrendingProvider;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ZodError | ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/feed/trending${QS.query(QS.explode({
        limit,
        cursor,
        viewer_fid: viewerFid,
        time_window: timeWindow,
        channel_id: channelId,
        provider
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve 10 most popular casts for a user
 */
export function getFarcasterFeedUserPopular(apiKey: string, fid: Fid, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkCastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/popular${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve recent replies and recasts for a user
 */
export function getFarcasterFeedUserRepliesAndRecasts(apiKey: string, fid: Fid, { filter, limit, cursor, viewerFid }: {
    filter?: "replies" | "recasts" | "all";
    limit?: number;
    cursor?: string;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/replies_and_recasts${QS.query(QS.explode({
        fid,
        filter,
        limit,
        cursor,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve casts for a user
 */
export function getFarcasterFeedUserCasts(apiKey: string, fid: Fid, { viewerFid, limit, cursor, includeReplies, parentUrl, channelId }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
    includeReplies?: boolean;
    parentUrl?: string;
    channelId?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/feed/user/casts${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        limit,
        cursor,
        include_replies: includeReplies,
        parent_url: parentUrl,
        channel_id: channelId
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve a frame by UUID or URL
 */
export function getFarcasterFrame(apiKey: string, $type: FrameType, { uuid, url }: {
    uuid?: string;
    url?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/frame${QS.query(QS.explode({
        "type": $type,
        uuid,
        url
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Create a new frame
 */
export function postFarcasterFrame(apiKey: string, neynarFrameCreationRequest: NeynarFrameCreationRequest, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "POST",
        body: neynarFrameCreationRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update an existing frame
 */
export function putFarcasterFrame(apiKey: string, neynarFrameUpdateRequest: NeynarFrameUpdateRequest, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "PUT",
        body: neynarFrameUpdateRequest,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a frame
 */
export function deleteFarcasterFrame(apiKey: string, body: {
    uuid?: string;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: DeleteFrameResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame", oazapfts.json({
        ...opts,
        method: "DELETE",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve a list of frames
 */
export function getFarcasterFrameList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NeynarFrame[];
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/frame/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches the frame meta tags from the URL
 */
export function getFarcasterFrameCrawl(apiKey: string, url: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: {
            frame: Frame;
        };
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/frame/crawl${QS.query(QS.explode({
        url
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a reaction
 */
export function postFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "POST",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a reaction
 */
export function deleteFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Adds verification for an ethereum address or contract for the user
 */
export function postFarcasterUserVerification(apiKey: string, addVerificationReqBody: AddVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "POST",
        body: addVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Removes verification for an eth address for the user
 */
export function deleteFarcasterUserVerification(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: removeVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Follow a user
 */
export function postFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "POST",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Unfollow a user
 */
export function deleteFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Lookup a user by custody-address
 */
export function getFarcasterUserCustodyAddress(apiKey: string, custodyAddress: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/custody-address${QS.query(QS.explode({
        custody_address: custodyAddress
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetch authorization url
 */
export function getFarcasterLoginAuthorize(apiKey: string, clientId: string, responseType: AuthorizationUrlResponseType, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: AuthorizationUrlResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    }>(`/farcaster/login/authorize${QS.query(QS.explode({
        client_id: clientId,
        response_type: responseType
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a frame signature packet
 */
export function postFarcasterFrameDeveloperManagedAction(apiKey: string, frameDeveloperManagedActionReqBody: FrameDeveloperManagedActionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Frame;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/developer_managed/action", oazapfts.json({
        ...opts,
        method: "POST",
        body: frameDeveloperManagedActionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Posts a frame action, cast action or a cast composer action
 */
export function postFarcasterFrameAction(apiKey: string, frameActionReqBody: FrameActionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Frame;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/action", oazapfts.json({
        ...opts,
        method: "POST",
        body: frameActionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Validates a frame action against Farcaster Hub
 */
export function postFarcasterFrameValidate(apiKey: string, body: {
    /** Hexadecimal string of message bytes. */
    message_bytes_in_hex: string;
    /** Adds viewer_context inside the cast object to indicate whether the interactor reacted to the cast housing the frame. */
    cast_reaction_context?: boolean;
    /** Adds viewer_context inside the user (interactor) object to indicate whether the interactor follows or is followed by the cast author. */
    follow_context?: boolean;
    /** Adds context about the app used by the user inside `frame.action`. */
    signer_context?: boolean;
    /** Adds context about the channel that the cast belongs to inside of the cast object. */
    channel_follow_context?: boolean;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ValidateFrameActionResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/validate", oazapfts.json({
        ...opts,
        method: "POST",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve a list of all the frames validated by a user
 */
export function getFarcasterFrameValidateList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FrameValidateListResponse;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/validate/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve analytics for the frame
 */
export function getFarcasterFrameValidateAnalytics(apiKey: string, frameUrl: string, analyticsType: ValidateFrameAnalyticsType, start: string, stop: string, { aggregateWindow }: {
    aggregateWindow?: "10s" | "1m" | "2m" | "5m" | "10m" | "20m" | "30m" | "2h" | "12h" | "1d" | "7d";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FrameValidateAnalyticsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 401;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/frame/validate/analytics${QS.query(QS.explode({
        frame_url: frameUrl,
        analytics_type: analyticsType,
        start,
        stop,
        aggregate_window: aggregateWindow
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a given user
 */
export function notifications(apiKey: string, fid: Fid, { $type, cursor }: {
    $type?: "follows" | "recasts" | "likes" | "mentions" | "replies";
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications${QS.query(QS.explode({
        fid,
        "type": $type,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given channels
 */
export function getFarcasterNotificationsChannel(apiKey: string, fid: Fid, channelIds: string, { cursor }: {
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/channel${QS.query(QS.explode({
        fid,
        channel_ids: channelIds,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given parent_urls
 */
export function getFarcasterNotificationsParentUrl(apiKey: string, fid: Fid, parentUrls: string, { cursor }: {
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/parent_url${QS.query(QS.explode({
        fid,
        parent_urls: parentUrls,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve all channels with their details
 */
export function getFarcasterChannelList(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/channel/list${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Search for channels based on id or name
 */
export function getFarcasterChannelSearch(apiKey: string, q: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelSearchResponse;
    }>(`/farcaster/channel/search${QS.query(QS.explode({
        q
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * (Bulk) Retrieve channels by id or parent_url
 */
export function getFarcasterChannelBulk(apiKey: string, ids: string, { $type, viewerFid }: {
    $type?: ChannelType;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelResponseBulk;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/bulk${QS.query(QS.explode({
        ids,
        "type": $type,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve channel details by id or parent_url
 */
export function getFarcasterChannel(apiKey: string, id: string, { $type, viewerFid }: {
    $type?: ChannelType;
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel${QS.query(QS.explode({
        id,
        "type": $type,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve followers for a given channel
 */
export function getFarcasterChannelFollowers(apiKey: string, id: string, { cursor, limit }: {
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/channel/followers${QS.query(QS.explode({
        id,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Get channels that a user is active in
 */
export function getFarcasterChannelUser(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersActiveChannelsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/user${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve users who are active in a channel
 */
export function getFarcasterChannelUsers(apiKey: string, id: string, hasRootCastAuthors: boolean, { hasCastLikers, hasCastRecasters, hasReplyAuthors, cursor, limit }: {
    hasCastLikers?: boolean;
    hasCastRecasters?: boolean;
    hasReplyAuthors?: boolean;
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/users${QS.query(QS.explode({
        id,
        has_root_cast_authors: hasRootCastAuthors,
        has_cast_likers: hasCastLikers,
        has_cast_recasters: hasCastRecasters,
        has_reply_authors: hasReplyAuthors,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve trending channels based on activity
 */
export function getFarcasterChannelTrending(apiKey: string, { timeWindow, limit, cursor }: {
    timeWindow?: "1d" | "7d" | "30d";
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: TrendingChannelResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/channel/trending${QS.query(QS.explode({
        time_window: timeWindow,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve followers for a given user
 */
export function getFarcasterFollowers(apiKey: string, fid: Fid, { viewerFid, sortType, limit, cursor }: {
    viewerFid?: Fid;
    sortType?: FollowSortType;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/followers${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        sort_type: sortType,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve relevant followers for a given user
 */
export function getFarcasterFollowersRelevant(apiKey: string, targetFid: Fid, viewerFid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: RelevantFollowersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/followers/relevant${QS.query(QS.explode({
        target_fid: targetFid,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve a list of users followed by a user
 */
export function getFarcasterFollowing(apiKey: string, fid: Fid, { viewerFid, sortType, limit, cursor }: {
    viewerFid?: Fid;
    sortType?: FollowSortType;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/following${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        sort_type: sortType,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches reactions for a given user
 */
export function getFarcasterReactionsUser(apiKey: string, fid: Fid, $type: ReactionsType, { viewerFid, limit, cursor }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ReactionsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/reactions/user${QS.query(QS.explode({
        fid,
        viewer_fid: viewerFid,
        "type": $type,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches reactions for a given cast
 */
export function getFarcasterReactionsCast(apiKey: string, hash: CastHash, types: string, { viewerFid, limit, cursor }: {
    viewerFid?: Fid;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ReactionsCastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/reactions/cast${QS.query(QS.explode({
        hash,
        types,
        viewer_fid: viewerFid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Check if a given fname is available
 */
export function getFarcasterFnameAvailability(apiKey: string, fname: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FnameAvailabilityResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/fname/availability${QS.query(QS.explode({
        fname
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage allocations for a given user
 */
export function getFarcasterStorageAllocations(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageAllocationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/allocations${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage usage for a given user
 */
export function getFarcasterStorageUsage(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageUsageResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/usage${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Buy storage for an fid
 */
export function postFarcasterStorageBuy(apiKey: string, buyStorageReqBody: BuyStorageReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageAllocationsResponse;
    } | {
        status: 400;
        data: ZodError;
    } | {
        status: 409;
        data: ConflictErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/storage/buy", oazapfts.json({
        ...opts,
        method: "POST",
        body: buyStorageReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetch a webhook
 */
export function getFarcasterWebhook(apiKey: string, webhookId: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/webhook${QS.query(QS.explode({
        webhook_id: webhookId
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Create a webhook
 */
export function postFarcasterWebhook(apiKey: string, webhookPostReqBody: WebhookPostReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "POST",
        body: webhookPostReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update webhook active status
 */
export function patchFarcasterWebhook(apiKey: string, webhookPatchReqBody: WebhookPatchReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "PATCH",
        body: webhookPatchReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Update a webhook
 */
export function putFarcasterWebhook(apiKey: string, webhookPutReqBody: WebhookPutReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "PUT",
        body: webhookPutReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a webhook
 */
export function deleteFarcasterWebhook(apiKey: string, webhookDeleteReqBody: WebhookDeleteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>("/farcaster/webhook", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: webhookDeleteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetch a list of webhooks associated to a user
 */
export function getFarcasterWebhookList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: WebhookListResponse;
    }>("/farcaster/webhook/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Get fids that a user has muted
 */
export function getFarcasterMuteList(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteListResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/mute/list${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Adds a mute for a fid
 */
export function postFarcasterMute(apiKey: string, muteReqBody: MuteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/mute", oazapfts.json({
        ...opts,
        method: "POST",
        body: muteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Deletes a mute for a fid
 */
export function deleteFarcasterMute(apiKey: string, muteReqBody: MuteReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: MuteResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/mute", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: muteReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Fetches all composer actions on Warpcast
 */
export function getFarcasterCastComposerActionsList(apiKey: string, list: CastComposerType, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastComposerActionsListResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/cast/composer_actions/list${QS.query(QS.explode({
        list,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
export enum Status {
    PendingApproval = "pending_approval",
    Approved = "approved",
    Revoked = "revoked"
}
export enum Status2 {
    Generated = "generated",
    PendingApproval = "pending_approval",
    Approved = "approved",
    Revoked = "revoked"
}
export enum Object_ {
    User = "user"
}
export enum ActiveStatus {
    Active = "active",
    Inactive = "inactive"
}
export enum Object2 {
    Channel = "channel"
}
export enum CastParamType {
    Url = "url",
    Hash = "hash"
}
export enum CastNotificationType {
    CastMention = "cast-mention",
    CastReply = "cast-reply"
}
export enum FrameButtonActionType {
    Post = "post",
    PostRedirect = "post_redirect",
    Tx = "tx"
}
export enum Object3 {
    ChannelDehydrated = "channel_dehydrated"
}
export enum FeedType {
    Following = "following",
    Filter = "filter"
}
export enum FilterType {
    Fids = "fids",
    ParentUrl = "parent_url",
    ChannelId = "channel_id",
    EmbedUrl = "embed_url",
    GlobalTrending = "global_trending"
}
export enum ForYouProvider {
    Openrank = "openrank",
    Karma3 = "karma3"
}
export enum SubscriptionProvider {
    FabricStp = "fabric_stp"
}
export enum SubscriptionProviders {
    FabricStp = "fabric_stp",
    Paragraph = "paragraph"
}
export enum FeedTrendingProvider {
    Neynar = "neynar",
    Openrank = "openrank"
}
export enum FrameType {
    Uuid = "uuid",
    Url = "url"
}
export enum Aspect_ratio {
    $1911 = "1.91:1",
    $11 = "1:1"
}
export enum Action_type {
    Post = "post",
    PostRedirect = "post_redirect",
    Mint = "mint",
    Link = "link"
}
export enum ReactionType {
    Like = "like",
    Recast = "recast"
}
export enum VerificationType {
    $0 = 0,
    $1 = 1
}
export enum VerificationChainId {
    $0 = 0,
    $1 = 1,
    $10 = 10
}
export enum AuthorizationUrlResponseType {
    Code = "code"
}
export enum Object4 {
    ValidatedFrameAction = "validated_frame_action"
}
export enum ValidateFrameAnalyticsType {
    TotalInteractors = "total-interactors",
    Interactors = "interactors",
    InteractionsPerCast = "interactions-per-cast",
    InputText = "input-text"
}
export enum Type {
    Follows = "follows",
    Recasts = "recasts",
    Likes = "likes",
    Mention = "mention",
    Reply = "reply"
}
export enum Object5 {
    Follow = "follow"
}
export enum Object6 {
    Likes = "likes",
    Recasts = "recasts"
}
export enum Object7 {
    CastDehydrated = "cast_dehydrated"
}
export enum ChannelType {
    Id = "id",
    ParentUrl = "parent_url"
}
export enum Object8 {
    ChannelActivity = "channel_activity"
}
export enum FollowSortType {
    DescChron = "desc_chron",
    Algorithmic = "algorithmic"
}
export enum Object9 {
    Follow = "follow"
}
export enum Object10 {
    UserDehydrated = "user_dehydrated"
}
export enum ReactionsType {
    All = "all",
    Likes = "likes",
    Recasts = "recasts"
}
export enum Reaction_type {
    Like = "like",
    Recast = "recast"
}
export enum Object11 {
    Likes = "likes",
    Recasts = "recasts"
}
export enum Object12 {
    Webhook = "webhook"
}
export enum Object13 {
    WebhookSubscription = "webhook_subscription"
}
export enum Active {
    True = "true",
    False = "false"
}
export enum Object14 {
    Mute = "mute"
}
export enum CastComposerType {
    Top = "top",
    Featured = "featured"
}
