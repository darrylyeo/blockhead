/**
 * Farcaster API V2
 * 2.0
 * DO NOT MODIFY - This file has been generated using oazapfts.
 * See https://www.npmjs.com/package/oazapfts
 */
import * as Oazapfts from "oazapfts/lib/runtime";
import * as QS from "oazapfts/lib/runtime/query";
export const defaults: Oazapfts.Defaults<Oazapfts.CustomHeaders> = {
    headers: {},
    baseUrl: "https://api.neynar.com/v2",
};
const oazapfts = Oazapfts.runtime(defaults);
export const servers = {
    server1: "https://api.neynar.com/v2"
};
export type SignerUuid = string;
export type Fid = number;
export type Signer = {
    signer_uuid: SignerUuid;
    public_key: string;
    status: Status;
    signer_approval_url?: string;
    fid?: Fid;
};
export type ErrorRes = {
    code?: string;
    message: string;
    property?: string;
    status?: number;
};
export type RegisterSignerKeyReqBody = {
    signer_uuid: SignerUuid;
    /** Signature generated by the custody address of the app. Signed data includes app_fid, deadline, signerâ€™s public key */
    signature: string;
    /** Application FID */
    app_fid: number;
    /** unix timestamp in seconds that controls how long the signed key request is valid for. (24 hours from now is recommended) */
    deadline: number;
};
export type Address = string;
export type User = {
    "object": Object_;
    fid: Fid;
    username: string;
    display_name: string;
    custody_address?: Address;
    /** The URL of the user's profile picture */
    pfp_url: string;
    profile: {
        bio: {
            text: string;
            mentioned_profiles: string[];
        };
    };
    /** The number of followers the user has. */
    follower_count: number;
    /** The number of users the user is following. */
    following_count: number;
    verifications: Address[];
    active_status: ActiveStatus;
    viewer_context?: {
        following: boolean;
        followed_by: boolean;
    };
};
export type ProfileUrl = {
    pfp: {
        url: string;
    };
};
export type SearchedUser = User & ProfileUrl;
export type UserSearchResponse = {
    result: {
        users: SearchedUser[];
    };
};
export type BulkUsersResponse = {
    users: User[];
};
export type BulkUsersByAddressResponse = {
    [key: string]: User[];
};
export type UpdateUserReqBody = {
    signer_uuid: SignerUuid;
    bio?: string;
    pfp_url?: string;
    url?: string;
    username?: string;
    display_name?: string;
};
export type OperationResponse = {
    success: boolean;
};
export type Timestamp = string;
export type EmbedUrl = {
    url: string;
};
export type CastId = {
    fid: Fid;
    hash: string;
};
export type EmbedCastId = {
    cast_id: CastId;
};
export type EmbeddedCast = EmbedUrl | EmbedCastId;
export type Cast = {
    hash: string;
    parent_hash: string | null;
    parent_url: string | null;
    parent_author: Fid & {
        fid: string | null;
    };
    author: User;
    text: string;
    timestamp: Timestamp;
    embeds: EmbeddedCast[];
    "type"?: CastNotificationType;
};
export type FrameActionButton = {
    /** Title of the button */
    title?: string;
    /** Index of the button */
    index: number;
    action_type?: FrameButtonActionType;
};
export type Frame = {
    /** Version of the frame */
    version: string;
    /** URL of the image */
    image: string;
    buttons?: FrameActionButton[];
    /** Post URL to take an action on this frame */
    post_url?: string;
    /** URL of the frames */
    frames_url: string;
};
export type ReactionLike = {
    fid: Fid;
};
export type ReactionRecast = {
    fid: Fid;
    fname: string;
};
export type CastWithInteractionsReactions = {
    likes: ReactionLike[];
    recasts: ReactionRecast[];
};
export type CastWithInteractionsReplies = {
    count: number;
};
export type CastWithInteractions = Cast & {
    frames?: Frame[];
    reactions: CastWithInteractionsReactions;
    replies: CastWithInteractionsReplies;
    thread_hash: string | null;
    mentioned_profiles: User[];
};
export type CastResponse = {
    cast: CastWithInteractions;
};
export type CastParent = string;
export type PostCastReqBody = {
    signer_uuid: SignerUuid;
    text?: string;
    embeds?: EmbeddedCast[];
    parent?: CastParent;
    /** Channel ID of the channel where the cast is to be posted. e.g. neynar, farcaster, warpcast */
    channel_id?: string;
};
export type PostCastResponse = {
    success: boolean;
    cast: {
        hash: Address;
        author: {
            fid: Fid;
        };
        text: string;
    };
};
export type DeleteCastReqBody = {
    signer_uuid: SignerUuid;
    target_hash: Address;
};
export type CastsResponse = {
    result: {
        casts: CastWithInteractions[];
    };
};
export type NextCursor = {
    cursor: string | null;
};
export type FeedResponse = {
    casts: CastWithInteractions[];
    next: NextCursor;
};
export type BulkCastsResponse = {
    casts: CastWithInteractions[];
};
export type ReactionReqBody = {
    signer_uuid: SignerUuid;
    reaction_type: ReactionType;
    target: string;
};
export type AddVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
    block_hash: string;
    eth_signature: string;
};
export type RemoveVerificationReqBody = {
    signer_uuid: SignerUuid;
    address: Address;
};
export type FollowReqBody = {
    signer_uuid: SignerUuid;
    target_fids: Fid[];
};
export type FollowResponse = {
    success: boolean;
    target_fid: Fid;
};
export type BulkFollowResponse = {
    success: boolean;
    details: FollowResponse[];
};
export type UserResponse = {
    user: User;
};
export type CastHash = string;
export type FrameInput = {
    /** Input text for the frame */
    text?: string;
};
export type FrameAction = {
    version?: string;
    title?: string;
    image?: string;
    button: FrameActionButton;
    input?: FrameInput;
    /** URL of the frames */
    frames_url: string;
    /** URL of the post to get the next frame */
    post_url: string;
};
export type FrameActionReqBody = {
    signer_uuid: SignerUuid;
    cast_hash: CastHash;
    action: FrameAction;
};
export type FrameActionResponse = {
    next_frame: Frame;
};
export type ValidatedFrameAction = {
    "object"?: Object2;
    interactor: User;
    button: FrameActionButton;
    input?: FrameInput;
    cast: CastWithInteractions;
};
export type ValidateFrameActionResponse = {
    valid: boolean;
    action?: ValidatedFrameAction;
};
export type Follow = {
    "object": Object3;
    user: User;
};
export type Reactions = {
    "object": Object4;
    cast: {
        hash: string;
        "object": Object5;
    };
    user: User;
};
export type Notification = {
    "object": string;
    most_recent_timestamp: string;
    "type": Type;
    follows?: Follow[];
    cast?: CastWithInteractions;
    reactions?: Reactions[];
};
export type NotificationsResponse = {
    notifications: Notification[];
    next: NextCursor;
};
export type Channel = {
    id: string;
    url: string;
    name?: string;
    description?: string;
    "object": Object6;
    /** Epoch timestamp in seconds. */
    created_at?: number;
    image_url?: string;
    lead?: User;
};
export type ChannelListResponse = {
    channels: Channel[];
};
export type ChannelResponse = {
    channel: Channel;
};
export type UsersResponse = {
    users: User[];
    next: NextCursor;
};
export type HydratedFollower = {
    "object"?: Object7;
    user?: User;
};
export type UserDehydrated = {
    "object"?: Object8;
    fid?: Fid;
};
export type DehydratedFollower = {
    "object"?: Object7;
    user?: UserDehydrated;
};
export type RelevantFollowersResponse = {
    top_relevant_followers_hydrated: HydratedFollower[];
    all_relevant_followers_dehydrated: DehydratedFollower[];
};
export type ReactionsResponse = {
    reactions: Reactions[];
    next: NextCursor;
};
export type FnameAvailabilityResponse = {
    available: boolean;
};
export type StorageAllocation = {
    "object"?: string;
    user?: UserDehydrated;
    units?: number;
    expiry?: string;
    timestamp?: string;
};
export type StorageAllocationsResponse = {
    total_active_units?: number;
    allocations?: StorageAllocation[];
};
export type StorageObject = {
    "object"?: string;
    used?: number;
    capacity?: number;
};
export type StorageUsageResponse = {
    "object"?: string;
    user?: UserDehydrated;
    casts?: StorageObject;
    reactions?: StorageObject;
    links?: StorageObject;
    verified_addresses?: StorageObject;
    username_proofs?: StorageObject;
    signers?: StorageObject;
    total_active_units?: number;
};
/**
 * Fetches the status of a signer
 */
export function signer(apiKey: string, signerUuid: SignerUuid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>(`/farcaster/signer${QS.query(QS.explode({
        signer_uuid: signerUuid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Creates a signer and returns the signer status
 */
export function postFarcasterSigner(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer", {
        ...opts,
        method: "POST",
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Register Signed Key
 */
export function postFarcasterSignerSignedKey(apiKey: string, registerSignerKeyReqBody: RegisterSignerKeyReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: Signer;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/signer/signed_key", oazapfts.json({
        ...opts,
        method: "POST",
        body: registerSignerKeyReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Search for Usernames
 */
export function getFarcasterUserSearch(apiKey: string, q: string, viewerFid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserSearchResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/search${QS.query(QS.explode({
        q,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches information about multiple users based on FIDs
 */
export function getFarcasterUserBulk(apiKey: string, fids: string, { viewerFid }: {
    viewerFid?: Fid;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/user/bulk${QS.query(QS.explode({
        fids,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches all users based on multiple Ethereum addresses
 */
export function getFarcasterUserBulkByAddress(apiKey: string, addresses: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkUsersByAddressResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/bulk-by-address${QS.query(QS.explode({
        addresses
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Update user profile
 */
export function patchFarcasterUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user", oazapfts.json({
        ...opts,
        method: "PATCH",
        body: updateUserReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve cast for a given hash or Warpcast URL
 */
export function cast(apiKey: string, identifier: string, $type: CastParamType, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/cast${QS.query(QS.explode({
        identifier,
        "type": $type
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a cast
 */
export function postFarcasterCast(apiKey: string, postCastReqBody: PostCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: PostCastResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "POST",
        body: postCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a cast
 */
export function deleteFarcasterCast(apiKey: string, deleteCastReqBody: DeleteCastReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/cast", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: deleteCastReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Gets information about an array of casts
 */
export function casts(apiKey: string, casts: string, { viewerFid, sortType }: {
    viewerFid?: Fid;
    sortType?: "trending" | "likes" | "recasts" | "replies" | "recent";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: CastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/casts${QS.query(QS.explode({
        casts,
        viewer_fid: viewerFid,
        sort_type: sortType
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve casts based on filters
 */
export function feed(apiKey: string, feedType: FeedType, { filterType, fid, fids, parentUrl, channelId, embedUrl, withRecasts, withReplies, limit, cursor }: {
    filterType?: FilterType;
    fid?: Fid;
    fids?: string;
    parentUrl?: string;
    channelId?: string;
    embedUrl?: string;
    withRecasts?: boolean;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed${QS.query(QS.explode({
        feed_type: feedType,
        filter_type: filterType,
        fid,
        fids,
        parent_url: parentUrl,
        channel_id: channelId,
        embed_url: embedUrl,
        with_recasts: withRecasts,
        with_replies: withReplies,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on who a user is following
 */
export function getFarcasterFeedFollowing(apiKey: string, fid: Fid, { withRecasts, withReplies, limit, cursor }: {
    withRecasts?: boolean;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/following${QS.query(QS.explode({
        fid,
        with_recasts: withRecasts,
        with_replies: withReplies,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed based on channel ids
 */
export function getFarcasterFeedChannels(apiKey: string, channelIds: string, { withRecasts, withReplies, limit, cursor }: {
    withRecasts?: boolean;
    withReplies?: boolean;
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/channels${QS.query(QS.explode({
        channel_ids: channelIds,
        with_recasts: withRecasts,
        with_replies: withReplies,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve feed of casts with Frames, reverse chronological order
 */
export function getFarcasterFeedFrames(apiKey: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/frames${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve 10 most popular casts for a user
 */
export function getFarcasterFeedUserByFidPopular(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkCastsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/${encodeURIComponent(fid)}/popular`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve recent replies and recasts for a user
 */
export function getFarcasterFeedUserByFidRepliesAndRecasts(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FeedResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/feed/user/${encodeURIComponent(fid)}/replies_and_recasts${QS.query(QS.explode({
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a reaction
 */
export function postFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "POST",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Delete a reaction
 */
export function deleteFarcasterReaction(apiKey: string, reactionReqBody: ReactionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/reaction", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: reactionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Adds verification for an eth address for the user
 */
export function postFarcasterUserVerification(apiKey: string, addVerificationReqBody: AddVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "POST",
        body: addVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Removes verification for an eth address for the user
 */
export function deleteFarcasterUserVerification(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: OperationResponse;
    }>("/farcaster/user/verification", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: removeVerificationReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Follow a user
 */
export function postFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "POST",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Unfollow a user
 */
export function deleteFarcasterUserFollow(apiKey: string, followReqBody: FollowReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: BulkFollowResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 403;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/user/follow", oazapfts.json({
        ...opts,
        method: "DELETE",
        body: followReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Lookup a user by custody-address
 */
export function getFarcasterUserCustodyAddress(apiKey: string, custodyAddress: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UserResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/user/custody-address${QS.query(QS.explode({
        custody_address: custodyAddress
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Posts a frame action
 */
export function postFarcasterFrameAction(apiKey: string, frameActionReqBody: FrameActionReqBody, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FrameActionResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/action", oazapfts.json({
        ...opts,
        method: "POST",
        body: frameActionReqBody,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Validates a frame action against Farcaster Hub
 */
export function postFarcasterFrameValidate(apiKey: string, body: {
    /** Hexadecimal string of message bytes. */
    message_bytes_in_hex: string;
    /** Adds viewer_context inside the cast object to indicate whether the interactor reacted to the cast housing the frame. */
    cast_reaction_context?: boolean;
    /** Adds viewer_context inside the user (interactor) object to indicate whether the interactor follows or is followed by the cast author. */
    follow_context?: boolean;
}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ValidateFrameActionResponse;
    } | {
        status: 400;
        data: ErrorRes;
    } | {
        status: 500;
        data: ErrorRes;
    }>("/farcaster/frame/validate", oazapfts.json({
        ...opts,
        method: "POST",
        body,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    })));
}
/**
 * Retrieve notifications for a given user
 */
export function notifications(apiKey: string, fid: Fid, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications${QS.query(QS.explode({
        fid,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given channels
 */
export function getFarcasterNotificationsChannel(apiKey: string, fid: Fid, channelIds: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/channel${QS.query(QS.explode({
        fid,
        channel_ids: channelIds,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve notifications for a user in given parent_urls
 */
export function getFarcasterNotificationsParentUrl(apiKey: string, fid: Fid, parentUrls: string, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: NotificationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/notifications/parent_url${QS.query(QS.explode({
        fid,
        parent_urls: parentUrls,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve all channels with their details
 */
export function getFarcasterChannelList(apiKey: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>("/farcaster/channel/list", {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Search for channels based on id or name
 */
export function getFarcasterChannelSearch(apiKey: string, q: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/channel/search${QS.query(QS.explode({
        q
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve channel details by id
 */
export function getFarcasterChannel(apiKey: string, id: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel${QS.query(QS.explode({
        id
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve followers for a given channel
 */
export function getFarcasterChannelFollowers(apiKey: string, id: string, { cursor, limit }: {
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/channel/followers${QS.query(QS.explode({
        id,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve users who are active in a channel
 */
export function getFarcasterChannelUsers(apiKey: string, id: string, hasRootCastAuthors: boolean, { hasCastLikers, hasCastRecasters, hasReplyAuthors, cursor, limit }: {
    hasCastLikers?: boolean;
    hasCastRecasters?: boolean;
    hasReplyAuthors?: boolean;
    cursor?: string;
    limit?: number;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: UsersResponse;
    } | {
        status: 404;
        data: ErrorRes;
    }>(`/farcaster/channel/users${QS.query(QS.explode({
        id,
        has_root_cast_authors: hasRootCastAuthors,
        has_cast_likers: hasCastLikers,
        has_cast_recasters: hasCastRecasters,
        has_reply_authors: hasReplyAuthors,
        cursor,
        limit
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve trending channels based on activity
 */
export function getFarcasterChannelTrending(apiKey: string, { timeWindow }: {
    timeWindow?: "1d" | "7d" | "30d";
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ChannelListResponse;
    }>(`/farcaster/channel/trending${QS.query(QS.explode({
        time_window: timeWindow
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Retrieve relevant followers for a given user
 */
export function getFarcasterFollowersRelevant(apiKey: string, targetFid: Fid, viewerFid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: RelevantFollowersResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/followers/relevant${QS.query(QS.explode({
        target_fid: targetFid,
        viewer_fid: viewerFid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches reactions for a given user
 */
export function getFarcasterReactionsUser(apiKey: string, fid: Fid, $type: ReactionsType, { limit, cursor }: {
    limit?: number;
    cursor?: string;
} = {}, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: ReactionsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/reactions/user${QS.query(QS.explode({
        fid,
        "type": $type,
        limit,
        cursor
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Check if a given fname is available
 */
export function getFarcasterFnameAvailability(apiKey: string, fname: string, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: FnameAvailabilityResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/fname/availability${QS.query(QS.explode({
        fname
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage allocations for a given user
 */
export function getFarcasterStorageAllocations(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageAllocationsResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/allocations${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
/**
 * Fetches storage usage for a given user
 */
export function getFarcasterStorageUsage(apiKey: string, fid: Fid, opts?: Oazapfts.RequestOpts) {
    return oazapfts.ok(oazapfts.fetchJson<{
        status: 200;
        data: StorageUsageResponse;
    } | {
        status: 400;
        data: ErrorRes;
    }>(`/farcaster/storage/usage${QS.query(QS.explode({
        fid
    }))}`, {
        ...opts,
        headers: oazapfts.mergeHeaders(opts?.headers, {
            api_key: apiKey
        })
    }));
}
export enum Status {
    Generated = "generated",
    PendingApproval = "pending_approval",
    Approved = "approved",
    Revoked = "revoked"
}
export enum Object_ {
    User = "user"
}
export enum ActiveStatus {
    Active = "active",
    Inactive = "inactive"
}
export enum CastParamType {
    Url = "url",
    Hash = "hash"
}
export enum CastNotificationType {
    CastMention = "cast-mention",
    CastReply = "cast-reply"
}
export enum FrameButtonActionType {
    Post = "post",
    PostRedirect = "post_redirect"
}
export enum FeedType {
    Following = "following",
    Filter = "filter"
}
export enum FilterType {
    Fids = "fids",
    ParentUrl = "parent_url",
    ChannelId = "channel_id",
    EmbedUrl = "embed_url",
    GlobalTrending = "global_trending"
}
export enum ReactionType {
    Like = "like",
    Recast = "recast"
}
export enum Object2 {
    ValidatedFrameAction = "validated_frame_action"
}
export enum Type {
    Follows = "follows",
    Recasts = "recasts",
    Likes = "likes",
    Mention = "mention",
    Reply = "reply"
}
export enum Object3 {
    Follow = "follow"
}
export enum Object4 {
    Likes = "likes",
    Recasts = "recasts"
}
export enum Object5 {
    CastDehydrated = "cast_dehydrated"
}
export enum Object6 {
    Channel = "channel"
}
export enum Object7 {
    Follow = "follow"
}
export enum Object8 {
    UserDehydrated = "user_dehydrated"
}
export enum ReactionsType {
    Likes = "likes",
    Recasts = "recasts",
    All = "all"
}
